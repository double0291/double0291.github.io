<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="chrome=1">

    

    <title>
      Python基础学习 | DoubleChen，就这样 
    </title>

    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
    
      <meta name="author" content="Double Chen">
    
    

    <meta name="description" content="基础知识数字和表达式除法普通情况下，整数被另一个整数除，结果只保留整数部分。12&amp;gt;&amp;gt;&amp;gt; 1/20
要执行普通的除法，有两种方法：

使用浮点数（Float）
12345678&amp;gt;&amp;gt;&amp;gt; 1.0 / 2.00.5&amp;gt;&amp;gt;&amp;gt; 1 / 2.00.5&amp;gt;&amp;gt;&amp;gt; 1 / 2.0.5

在程序前加上下面这句：
1from __future__ imp">
<meta property="og:type" content="article">
<meta property="og:title" content="Python基础学习 | DoubleChen，就这样">
<meta property="og:url" content="http://yoursite.com/2015/12/10/python_learning/index.html">
<meta property="og:site_name" content="DoubleChen，就这样">
<meta property="og:description" content="基础知识数字和表达式除法普通情况下，整数被另一个整数除，结果只保留整数部分。12&amp;gt;&amp;gt;&amp;gt; 1/20
要执行普通的除法，有两种方法：

使用浮点数（Float）
12345678&amp;gt;&amp;gt;&amp;gt; 1.0 / 2.00.5&amp;gt;&amp;gt;&amp;gt; 1 / 2.00.5&amp;gt;&amp;gt;&amp;gt; 1 / 2.0.5

在程序前加上下面这句：
1from __future__ imp">
<meta property="og:updated_time" content="2016-01-25T11:28:27.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Python基础学习 | DoubleChen，就这样">
<meta name="twitter:description" content="基础知识数字和表达式除法普通情况下，整数被另一个整数除，结果只保留整数部分。12&amp;gt;&amp;gt;&amp;gt; 1/20
要执行普通的除法，有两种方法：

使用浮点数（Float）
12345678&amp;gt;&amp;gt;&amp;gt; 1.0 / 2.00.5&amp;gt;&amp;gt;&amp;gt; 1 / 2.00.5&amp;gt;&amp;gt;&amp;gt; 1 / 2.0.5

在程序前加上下面这句：
1from __future__ imp">
    
    
    
      <link rel="icon" type="image/x-icon" href="/images/favicon.ico">
    
    <link rel="stylesheet" href="/css/uno.css" type="text/css">
    <link rel="stylesheet" href="/css/highlight.css" type="text/css">
    <link rel="stylesheet" href="/css/archive.css" type="text/css">

</head>
<body>

    <span class="mobile btn-mobile-menu">
        <i class="icon icon-list btn-mobile-menu__icon"></i>
        <i class="icon icon-x-circle btn-mobile-close__icon hidden"></i>
    </span>

    

<header class="panel-cover panel-cover--collapsed">


  <div class="panel-main">

    <div class="panel-main__inner panel-inverted">
    <div class="panel-main__content">

        
        <a href="/" title="link to homepage for DoubleChen，就这样"><img src="/images/avatar.png" width="80" alt="DoubleChen，就这样 logo" class="panel-cover__logo logo" /></a>
        

        <h1 class="panel-cover__title panel-title"><a href="/" title="link to homepage">DoubleChen，就这样</a></h1>
        <hr class="panel-cover__divider" />

        

        <div class="navigation-wrapper">

          <nav class="cover-navigation cover-navigation--primary">
            <ul class="navigation">

              
                
                <li class="navigation__item"><a href="/#blog" title="" class="blog-button">首页</a></li>
              
                
                <li class="navigation__item"><a href="/archives" title="" class="">归档</a></li>
              

            </ul>
          </nav>

          <!-- ----------------------------
To add a new social icon simply duplicate one of the list items from below
and change the class in the <i> tag to match the desired social network
and then add your link to the <a>. Here is a full list of social network
classes that you can use:

    icon-social-500px
    icon-social-behance
    icon-social-delicious
    icon-social-designer-news
    icon-social-deviant-art
    icon-social-digg
    icon-social-dribbble
    icon-social-facebook
    icon-social-flickr
    icon-social-forrst
    icon-social-foursquare
    icon-social-github
    icon-social-google-plus
    icon-social-hi5
    icon-social-instagram
    icon-social-lastfm
    icon-social-linkedin
    icon-social-medium
    icon-social-myspace
    icon-social-path
    icon-social-pinterest
    icon-social-rdio
    icon-social-reddit
    icon-social-skype
    icon-social-spotify
    icon-social-stack-overflow
    icon-social-steam
    icon-social-stumbleupon
    icon-social-treehouse
    icon-social-tumblr
    icon-social-twitter
    icon-social-vimeo
    icon-social-xbox
    icon-social-yelp
    icon-social-youtube
    icon-social-zerply
    icon-mail

-------------------------------->

<!-- add social info here -->



        </div>

      </div>

    </div>

    <div class="panel-cover--overlay"></div>
  </div>
</header>

    <div class="content-wrapper">
        <div class="content-wrapper__inner entry">
            

<article class="post-container post-container--single">

  <header class="post-header">
    
    <h1 class="post-title">Python基础学习</h1>

    

    <div class="post-meta">
      <time datetime="2015-12-10" class="post-meta__date date">2015-12-10</time> 

      <span class="post-meta__tags tags">

          

          
             &#8226; 标签:
            <font class="tags">
              <a class="tags-link" href="/tags/python/">python</a>
            </font>
          

      </span>
    </div>
    
    

  </header>

  <section id="post-content" class="article-content post">
    <h2 id="基础知识">基础知识</h2><h3 id="数字和表达式">数字和表达式</h3><h4 id="除法">除法</h4><p>普通情况下，整数被另一个整数除，结果只保留整数部分。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="prompt">&gt;&gt;&gt; </span><span class="number">1</span>/<span class="number">2</span></span><br><span class="line"><span class="number">0</span></span><br></pre></td></tr></table></figure></p>
<p>要执行普通的除法，有两种方法：</p>
<ol>
<li><p>使用浮点数（Float）</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="prompt">&gt;&gt;&gt; </span><span class="number">1.0</span> / <span class="number">2.0</span></span><br><span class="line"><span class="number">0.5</span></span><br><span class="line"></span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span><span class="number">1</span> / <span class="number">2.0</span></span><br><span class="line"><span class="number">0.5</span></span><br><span class="line"></span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span><span class="number">1</span> / <span class="number">2.</span></span><br><span class="line"><span class="number">0.5</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>在程序前加上下面这句：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> __future__ <span class="keyword">import</span> division</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h4 id="整除操作符">整除操作符</h4><p>python提供了另一个用于实现整除的操作符——双斜线，即使是浮点数，也会执行整除：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="prompt">&gt;&gt;&gt; </span><span class="number">1</span> // <span class="number">2</span></span><br><span class="line"><span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span><span class="number">1.0</span> // <span class="number">2.0</span></span><br><span class="line"><span class="number">0.0</span></span><br></pre></td></tr></table></figure></p>
<h4 id="幂运算符">幂运算符</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="prompt">&gt;&gt;&gt; </span><span class="number">2</span> ** <span class="number">3</span></span><br><span class="line"><span class="number">8</span></span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span>-<span class="number">3</span> ** <span class="number">2</span></span><br><span class="line">-<span class="number">9</span></span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span>(-<span class="number">3</span>) ** <span class="number">2</span></span><br><span class="line"><span class="number">9</span></span><br></pre></td></tr></table></figure>
<p>幂运算符的优先级高于取反。</p>
<h3 id="变量">变量</h3><p>变量名可以包括字母，数字和下划线，但是变量不能以数字开头。</p>
<h3 id="模块">模块</h3><p>普通模块导入按照“模块.函数”的格式使用这个模块的函数<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="prompt">&gt;&gt;&gt; </span><span class="keyword">import</span> math</span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span>math.floor(<span class="number">32.9</span>)</span><br><span class="line"><span class="number">32.0</span></span><br></pre></td></tr></table></figure></p>
<p>如果确认自己不会导入多个同名函数（从不同的模块导入），可以使用另一种导入模块的方式，这样每次调用函数的时候就不需要写上模块的名字了<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="prompt">&gt;&gt;&gt; </span><span class="keyword">from</span> math <span class="keyword">import</span> sqrt</span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span>sqrt(<span class="number">9</span>)</span><br><span class="line"><span class="number">3.0</span></span><br></pre></td></tr></table></figure></p>
<p>为了不写模块名字，还可以通过变量来引用函数<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="prompt">&gt;&gt;&gt; </span><span class="keyword">import</span> math</span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span>foo = math.sqrt</span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span>foo(<span class="number">4</span>)</span><br><span class="line"><span class="number">2.0</span></span><br></pre></td></tr></table></figure></p>
<h3 id="__future__">__future__</h3><p>通过__future__可以导入那些在未来会成为python组成部分的新特征。</p>
<h2 id="序列">序列</h2><p>Python有6种内建序列，</p>
<ol>
<li>列表</li>
<li>元组</li>
<li>字符串</li>
<li>Unicode字符串</li>
<li>buffer对象</li>
<li>xrange对象</li>
</ol>
<p>序列主要用来操作一组数值。<br>比如可以表示一个人的信息，下面的序列第一个元素是姓名，第二个元素是年龄。<br>可以看到，序列的元素不需要是同一类型，序列也可以包括其他序列。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="prompt">&gt;&gt;&gt; </span>edawrd = [<span class="string">'Edward Gumby'</span>, <span class="number">42</span>]</span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span>john = [<span class="string">'John Smith'</span>, <span class="number">50</span>]</span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span>database = [edward, john]</span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span>database</span><br><span class="line">[[<span class="string">'Edward Gumby'</span>, <span class="number">42</span>], [<span class="string">'John Smith'</span>, <span class="number">50</span>]]</span><br></pre></td></tr></table></figure></p>
<h3 id="通用序列操作">通用序列操作</h3><p>所有的序列类型都可以进行一些操作，包括：索引（indexing），分片（sliceing），加（adding），乘（multiplying）以及检查某个元素是否属于序列。<br>初次之外，Python还有计算序列长度，找到最大元素和最小元素的内建函数。</p>
<h4 id="索引">索引</h4><p>序列中所有元素都是从0开始编号的。<br>可以直接通过编号访问：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="prompt">&gt;&gt;&gt; </span>greeting = <span class="string">'Hello'</span></span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span>greeting[<span class="number">0</span>]</span><br><span class="line"><span class="string">'H'</span></span><br></pre></td></tr></table></figure></p>
<p>可以看到，字符串就是一个由字符组成的序列。<br>可以通过索引获取元素，所有序列都可以通过这种方式进行索引。<br>使用负数索引时，Python就会从右边，也就是最后一个元素开始计数。<br><strong>最后一个元素的位置编号是-1（不是-0，因为这样的话，会跟第一个元素重合）。</strong><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="prompt">&gt;&gt;&gt; </span>squares = [<span class="number">1</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">16</span>, <span class="number">25</span>]</span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span>squares[<span class="number">0</span>]</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span>squares[-<span class="number">1</span>]</span><br><span class="line"><span class="number">25</span></span><br></pre></td></tr></table></figure></p>
<h4 id="分片">分片</h4><p>分片操作主要用来访问一定范围内的元素。<br>分片通过冒号相隔的两个索引来实现。<br>第一个索引是需要提取部分的第一个元素的编号，第二个索引则是分片后剩下部分的第一个元素的编号。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="prompt">&gt;&gt;&gt; </span>tag = <span class="string">'&lt;a href="http://www.python.org"&gt;Python web site&lt;/a&gt;'</span></span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span>tag[<span class="number">9</span>:<span class="number">30</span>]</span><br><span class="line"><span class="string">'http://www.python.org'</span></span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span>tag[<span class="number">32</span>:-<span class="number">4</span>]</span><br><span class="line"><span class="string">'Python web site'</span></span><br><span class="line"></span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span>numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>]</span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span>numbers[<span class="number">3</span>:<span class="number">6</span>]</span><br><span class="line">[<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]</span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span>numbers[<span class="number">0</span>:<span class="number">1</span>]</span><br><span class="line">[<span class="number">1</span>]</span><br></pre></td></tr></table></figure></p>
<h5 id="捷径">捷径</h5><p>如果要访问最后三个元素，可以显示操作：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="prompt">&gt;&gt;&gt; </span>numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>]</span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span>numbers[<span class="number">7</span>:<span class="number">10</span>]</span><br><span class="line">[<span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>]</span><br></pre></td></tr></table></figure></p>
<p>索引10指向了第11个元素，这个元素并不存在，但是却在最后一个元素的后面。<br>但如果想从队尾开始计数就麻烦了：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="prompt">&gt;&gt;&gt; </span>numbers[-<span class="number">3</span>:-<span class="number">1</span>]</span><br><span class="line">[<span class="number">8</span>, <span class="number">9</span>]</span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span>numbers[-<span class="number">3</span>:<span class="number">0</span>]</span><br><span class="line">[]</span><br></pre></td></tr></table></figure></p>
<p>正确的做法就是置空最后一个索引：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="prompt">&gt;&gt;&gt; </span>numbers[-<span class="number">3</span>:]</span><br><span class="line">[<span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>]</span><br></pre></td></tr></table></figure></p>
<p>这种方式同样适用于序列开始：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="prompt">&gt;&gt;&gt; </span>numbers[:<span class="number">3</span>]</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br></pre></td></tr></table></figure></p>
<p>如果要复制整个序列，设置可以将两个索引都置空：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="prompt">&gt;&gt;&gt; </span>numbers[:]</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>]</span><br></pre></td></tr></table></figure></p>
<h5 id="步长">步长</h5><p>分片需要制定开始和计数的索引，其实，还有另一个隐藏的参数——步长（step length）。<br>普通分片中，步长默认为1，如果重设步长，就会跳步：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="prompt">&gt;&gt;&gt; </span>numbers[<span class="number">0</span>:<span class="number">10</span>:<span class="number">1</span>]</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>]</span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span>numbers[<span class="number">0</span>:<span class="number">10</span>:<span class="number">2</span>]</span><br><span class="line">[<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>]</span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span>numbers[<span class="number">3</span>:<span class="number">6</span>:<span class="number">3</span>]</span><br><span class="line">[<span class="number">4</span>]</span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span>numbers[::<span class="number">4</span>]</span><br><span class="line">[<span class="number">1</span>, <span class="number">5</span>, <span class="number">9</span>]</span><br></pre></td></tr></table></figure></p>
<p>步长不能为0，那样就不会向下执行了，会报异常。<br>但步长可以为负数，就会从右到左提取元素：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="prompt">&gt;&gt;&gt; </span>numbers[<span class="number">8</span>:<span class="number">3</span>:-<span class="number">1</span>]</span><br><span class="line">[<span class="number">9</span>, <span class="number">8</span>, <span class="number">7</span>, <span class="number">6</span>, <span class="number">5</span>]</span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span>numbers[<span class="number">10</span>:<span class="number">0</span>:-<span class="number">2</span>]</span><br><span class="line">[<span class="number">10</span>, <span class="number">8</span>, <span class="number">6</span>, <span class="number">4</span>, <span class="number">2</span>]</span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span>numbers[<span class="number">0</span>:<span class="number">10</span>:-<span class="number">2</span>]</span><br><span class="line">[]</span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span>numbers[::-<span class="number">2</span>]</span><br><span class="line">[<span class="number">10</span>, <span class="number">8</span>, <span class="number">6</span>, <span class="number">4</span>, <span class="number">2</span>]</span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span>numbers[<span class="number">5</span>::-<span class="number">2</span>]</span><br><span class="line">[<span class="number">6</span>, <span class="number">4</span>, <span class="number">2</span>]</span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span>numbers[:<span class="number">5</span>:-<span class="number">2</span>]</span><br><span class="line">[<span class="number">10</span>, <span class="number">8</span>]</span><br></pre></td></tr></table></figure></p>
<h4 id="加">加</h4><p>加号可以执行序列的连接操作：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="prompt">&gt;&gt;&gt; </span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>] + [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]</span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span><span class="string">'Hello '</span> + <span class="string">"World"</span></span><br><span class="line"><span class="string">'Hello World'</span></span><br></pre></td></tr></table></figure></p>
<p>但是要注意，<strong>同类型的序列才可以进行连接操作，比如字符串和列表相加会抛异常</strong>。</p>
<h4 id="乘">乘</h4><p>数字n乘以序列会生成新的序列，新的序列中，旧的序列被重复了n次。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="prompt">&gt;&gt;&gt; </span><span class="string">'python'</span> * <span class="number">5</span></span><br><span class="line"><span class="string">'pythonpythonpythonpythonpython'</span></span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span>[<span class="number">42</span>] * <span class="number">3</span></span><br><span class="line">[<span class="number">42</span>, <span class="number">42</span>, <span class="number">42</span>]</span><br></pre></td></tr></table></figure></p>
<p>如果想初始化一个长度为10的空列表：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="prompt">&gt;&gt;&gt; </span>sequence = [<span class="keyword">None</span>] * <span class="number">10</span></span><br><span class="line">[<span class="keyword">None</span>, <span class="keyword">None</span>, <span class="keyword">None</span>, <span class="keyword">None</span>, <span class="keyword">None</span>, <span class="keyword">None</span>, <span class="keyword">None</span>, <span class="keyword">None</span>, <span class="keyword">None</span>, <span class="keyword">None</span>]</span><br></pre></td></tr></table></figure></p>
<h4 id="成员资格">成员资格</h4><p><em>in</em>运算符用来检查一个值是否在序列中：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="prompt">&gt;&gt;&gt; </span>permission = <span class="string">'rw'</span></span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span><span class="string">'w'</span> <span class="keyword">in</span> permission</span><br><span class="line"><span class="keyword">True</span></span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span><span class="string">'x'</span> <span class="keyword">in</span> permission</span><br><span class="line"><span class="keyword">False</span></span><br></pre></td></tr></table></figure></p>
<h4 id="长度、最大值和最小值">长度、最大值和最小值</h4><p>长度、最大值和最小值对应的内建函数分别是<em>len</em>，<em>max</em>，<em>min</em>。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="prompt">&gt;&gt;&gt; </span>numbers = [<span class="number">100</span>, <span class="number">34</span>, <span class="number">678</span>]</span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span>len(numbers)</span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span>max(numbers)</span><br><span class="line"><span class="number">678</span></span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span>min(numbers)</span><br><span class="line"><span class="number">34</span></span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span>max(<span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span>min(<span class="number">9</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">5</span>)</span><br><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure></p>
<h3 id="列表和元组">列表和元组</h3><p>列表和元组主要区别在于，<strong>列表可以修改，元组则不能</strong>。<br>几乎所有情况下列表都可以取代元组，除了一种例外：<strong>使用元组作为字典的键，这种情况下，因为键不可以修改，所以就不能使用列表</strong>。</p>
<h4 id="列表">列表</h4><p>列表是可变的，而且有很多专有方法。    </p>
<h5 id="list函数"><em>list</em>函数</h5><p>字符串不能像列表一样被修改，有时候需要根据字符串创建列表，这个操作通过<em>list</em>函数进行。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="prompt">&gt;&gt;&gt; </span>list(<span class="string">'Hello'</span>)</span><br><span class="line">[<span class="string">'H'</span>, <span class="string">'e'</span>, <span class="string">'l'</span>, <span class="string">'l'</span>, <span class="string">'o'</span>]</span><br></pre></td></tr></table></figure></p>
<p><em>list</em>函数适用于所有的序列</p>
<h5 id="基本列表操作">基本列表操作</h5><p>除了所有的序列基本操作，列表还有很多属于自己的方法：元素赋值，元素删除，分片赋值等等。</p>
<h6 id="元素赋值">元素赋值</h6><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="prompt">&gt;&gt;&gt; </span>x = [<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>]</span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span>x[<span class="number">1</span>] = <span class="number">2</span></span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span>x</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>]</span><br></pre></td></tr></table></figure>
<p>不能给位置不存在的元素进行赋值，会抛异常。</p>
<h6 id="元素删除">元素删除</h6><p>删除元素通过<em>del</em>语句实现<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="prompt">&gt;&gt;&gt; </span>names = [<span class="string">'Alice'</span>, <span class="string">'Beth'</span>, <span class="string">'Cecil'</span>]</span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span><span class="keyword">del</span> names[<span class="number">1</span>]</span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span>names</span><br><span class="line">[<span class="string">'Alice'</span>, <span class="string">'Cecil'</span>]</span><br></pre></td></tr></table></figure></p>
<h6 id="分片赋值">分片赋值</h6><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="prompt">&gt;&gt;&gt; </span>name = list(<span class="string">'Perl'</span>)</span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span>name</span><br><span class="line">[<span class="string">'P'</span>, <span class="string">'e'</span>, <span class="string">'r'</span>, <span class="string">'l'</span>]</span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span>name[<span class="number">2</span>:] = list(<span class="string">'ar'</span>)</span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span>name</span><br><span class="line">[<span class="string">'P'</span>, <span class="string">'e'</span>, <span class="string">'a'</span> <span class="string">'r'</span>]</span><br></pre></td></tr></table></figure>
<p>分片赋值还可以使用与原序列不等长的序列将分片替换<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="prompt">&gt;&gt;&gt; </span>name = list(<span class="string">'Perl'</span>)</span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span>name[<span class="number">1</span>:] = list(<span class="string">'ython'</span>)</span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span>name</span><br><span class="line">[<span class="string">'P'</span>, <span class="string">'y'</span>, <span class="string">'t'</span>, <span class="string">'h'</span>, <span class="string">'o'</span>, n]</span><br></pre></td></tr></table></figure></p>
<p>分片赋值也可以在不替换任何原有元素的情况下插入新的元素<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="prompt">&gt;&gt;&gt; </span>numbers = [<span class="number">1</span>, <span class="number">5</span>]</span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span>numbers[<span class="number">1</span>:<span class="number">1</span>] = [<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span>numbers</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br></pre></td></tr></table></figure></p>
<p>甚至可以通过分片赋值删除元素<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="prompt">&gt;&gt;&gt; </span>numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span>numbers[<span class="number">1</span>:<span class="number">4</span>] = []</span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span>numbers</span><br><span class="line">[<span class="number">1</span>, <span class="number">5</span>]</span><br></pre></td></tr></table></figure></p>
<h5 id="列表方法">列表方法</h5><p><em>append</em><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="prompt">&gt;&gt;&gt; </span>lst = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span>lst.append(<span class="number">4</span>)</span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span>lst</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br></pre></td></tr></table></figure></p>
<p><em>count</em><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="prompt">&gt;&gt;&gt; </span>[<span class="string">'to'</span>, <span class="string">'be'</span>, <span class="string">'or'</span>, <span class="string">'not'</span>, <span class="string">'to'</span>, <span class="string">'be'</span>].count(<span class="string">'to'</span>)</span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span>x = [[<span class="number">1</span>, <span class="number">2</span>], <span class="number">1</span>, <span class="number">1</span>, [<span class="number">2</span>, <span class="number">1</span>, [<span class="number">1</span>, <span class="number">2</span>]]]</span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span>x.count(<span class="number">1</span>)</span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span>x.count([<span class="number">1</span>, <span class="number">2</span>])</span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure></p>
<p><em>extend</em><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="prompt">&gt;&gt;&gt; </span>a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span>b = [<span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span>a.extend(b)</span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span>a</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br></pre></td></tr></table></figure></p>
<p><em>extend</em>与连接操作的区别在于：<br><strong>extend方法修改了被扩展的序列，而原始的连接操作则会返回一个全新的列表</strong>：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="prompt">&gt;&gt;&gt; </span>a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span>b = [<span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span>a + b</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span>a</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br></pre></td></tr></table></figure></p>
<p>也可以通过以下方式实现，但是<strong>效率没有extend高</strong><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="prompt">&gt;&gt;&gt; </span>a = a + b</span><br></pre></td></tr></table></figure></p>
<p>或者<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a[len(a):] = b</span><br></pre></td></tr></table></figure></p>
<p><em>index</em><br>返回从列表中找出某个值第一个匹配项的索引位置<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="prompt">&gt;&gt;&gt; </span>knights = [<span class="string">'we'</span>, <span class="string">'are'</span>, <span class="string">'the'</span>, <span class="string">'knights'</span>, <span class="string">'who'</span>, <span class="string">'say'</span>, <span class="string">'ni'</span>]</span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span>knights.index(<span class="string">'who'</span>)</span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span>knights.index(<span class="string">'herring'</span>)</span><br><span class="line">ValueError: list.index(x): x <span class="keyword">not</span> <span class="keyword">in</span> list</span><br></pre></td></tr></table></figure></p>
<p>如果搜索的元素不在列表中，会抛异常。</p>
<p><em>insert</em><br><em>insert</em>用于插入元素到列表中：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="prompt">&gt;&gt;&gt; </span>numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">6</span>]</span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span>numbers.insert(<span class="number">3</span>, <span class="string">'four'</span>)</span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span>numbers</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="string">'four'</span>, <span class="number">5</span>, <span class="number">6</span>]</span><br></pre></td></tr></table></figure></p>
<p>与<em>extend</em>方法一样，<em>insert</em>方法的操作也可以通过分片赋值来实现<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="prompt">&gt;&gt;&gt; </span>numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">6</span>]</span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span>numbers[<span class="number">3</span>:<span class="number">3</span>] = [<span class="string">'four'</span>]</span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span>numbers</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="string">'four'</span>, <span class="number">5</span>, <span class="number">6</span>]</span><br></pre></td></tr></table></figure></p>
<p>只是这样实现的可读性比较差。</p>
<p><em>pop</em><br><em>pop</em>方法移除列表中的一个元素（默认最后一个），并返回该元素的值：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="prompt">&gt;&gt;&gt; </span>x = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span>x.pop()</span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span>x</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span>x.pop(<span class="number">0</span>)</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span>x</span><br><span class="line">[<span class="number">2</span>]</span><br></pre></td></tr></table></figure></p>
<p><em>remove</em><br><em>remove</em>方法移除列表中某个值的第一个匹配项<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="prompt">&gt;&gt;&gt; </span>x = [<span class="string">'to'</span>, <span class="string">'be'</span>, <span class="string">'or'</span>, <span class="string">'not'</span>, <span class="string">'to'</span>, <span class="string">'be'</span>]</span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span>x.remove(<span class="string">"be"</span>)</span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span>x</span><br><span class="line">[<span class="string">'to'</span>, <span class="string">'or'</span>, <span class="string">'not'</span>, <span class="string">'to'</span>, <span class="string">'be'</span>]</span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span>x.remove(<span class="string">'bee'</span>)</span><br><span class="line">ValueError: list.remove(x): x <span class="keyword">not</span> <span class="keyword">in</span> list</span><br></pre></td></tr></table></figure></p>
<p><em>remove</em>方法没有返回值，跟<em>pop</em>不一样。</p>
<p><em>reverse</em><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="prompt">&gt;&gt;&gt; </span>x = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span>x.reverse()</span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span>x</span><br><span class="line">[<span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>]</span><br></pre></td></tr></table></figure></p>
<p><em>sort</em><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="prompt">&gt;&gt;&gt; </span>x = [<span class="number">4</span>, <span class="number">6</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">7</span>, <span class="number">9</span>]</span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span>x.sort()</span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span>x</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">9</span>]</span><br></pre></td></tr></table></figure></p>
<p>注意，<em>sort</em>方法对原列表进行排序，这意味着改变了原列表，并不是返回一个已排序的列表副本。<br>所以，如果需要一个排序的副本，下面的做法是<strong>错误</strong>的：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="prompt">&gt;&gt;&gt; </span>x = [<span class="number">4</span>, <span class="number">6</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">7</span>, <span class="number">9</span>]</span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span>y = x.sort()</span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span><span class="keyword">print</span> y</span><br><span class="line"><span class="keyword">None</span></span><br></pre></td></tr></table></figure></p>
<p>因为<em>sort</em>方法修改了x却返回了空值。<br>实现返回序列排序副本的正确方法是先将x的副本赋值给y，然后对y进行排序：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="prompt">&gt;&gt;&gt; </span>x = [<span class="number">4</span>, <span class="number">6</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">7</span>, <span class="number">9</span>]</span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span>y = x[:]</span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span>y.sort()</span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span>x</span><br><span class="line">[<span class="number">4</span>, <span class="number">6</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">7</span>, <span class="number">9</span>]</span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span>y</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">9</span>]</span><br></pre></td></tr></table></figure></p>
<p>简单的将x赋值给y是没用的，这就让x和y指向了同一个列表：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="prompt">&gt;&gt;&gt; </span>y = x</span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span>y.sort()</span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span>x</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">9</span>]</span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span>y</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">9</span>]</span><br></pre></td></tr></table></figure></p>
<p><strong>另外一种获取已排序副本的方法就是使用sorted函数</strong>：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="prompt">&gt;&gt;&gt; </span>x = [<span class="number">4</span>, <span class="number">6</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">7</span>, <span class="number">9</span>]</span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span>y = sorted(x)</span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span>x</span><br><span class="line">[<span class="number">4</span>, <span class="number">6</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">7</span>, <span class="number">9</span>]</span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span>y</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">9</span>]</span><br></pre></td></tr></table></figure></p>
<p><em>sorted</em>函数可以用于任何序列，但是总是返回一个列表：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="prompt">&gt;&gt;&gt; </span>sorted(<span class="string">'Python'</span>)</span><br><span class="line">[<span class="string">'P'</span>, <span class="string">'h'</span>, <span class="string">'n'</span>, <span class="string">'o'</span>, <span class="string">'t'</span>, y]</span><br></pre></td></tr></table></figure></p>
<h4 id="元组">元组</h4><p>元组跟列表一样，是一种序列，但是元组不能够修改。<br>创建元组的方式很简单，用逗号分隔一些值，就自动创建了元组：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="prompt">&gt;&gt;&gt; </span><span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span></span><br><span class="line">(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br></pre></td></tr></table></figure></p>
<p>也可以通过圆括号括起来：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="prompt">&gt;&gt;&gt; </span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line">(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br></pre></td></tr></table></figure></p>
<p>要实现只包括一个值的元素，必须加括号：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="prompt">&gt;&gt;&gt; </span><span class="number">42</span></span><br><span class="line"><span class="number">42</span></span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span>(<span class="number">42</span>)</span><br><span class="line"><span class="number">42</span></span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span><span class="number">42</span>,</span><br><span class="line">(<span class="number">42</span>,)</span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span>(<span class="number">42</span>,)</span><br><span class="line">(<span class="number">42</span>,)</span><br></pre></td></tr></table></figure></p>
<p>一个逗号能改变很多东西，比如：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="prompt">&gt;&gt;&gt; </span><span class="number">3</span> * (<span class="number">40</span> + <span class="number">2</span>)</span><br><span class="line"><span class="number">126</span></span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span><span class="number">3</span> * (<span class="number">40</span> + <span class="number">2</span>,)</span><br><span class="line">(<span class="number">42</span>, <span class="number">42</span>, <span class="number">42</span>)</span><br></pre></td></tr></table></figure></p>
<h5 id="tuple"><em>tuple</em></h5><p><em>tuple</em>函数以一个序列为参数并将其转换为元组。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="prompt">&gt;&gt;&gt; </span>tuple([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line">(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span>tuple(<span class="string">'abc'</span>)</span><br><span class="line">(<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>)</span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span>tuple((<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>))</span><br><span class="line">(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br></pre></td></tr></table></figure></p>
<h5 id="元组操作">元组操作</h5><p>差不多就是序列操作</p>
<h5 id="元组意义">元组意义</h5><ul>
<li>元组可以在映射（和集合的成员）中当做键使用，<strong>而列表不行</strong>。</li>
<li>元组作为很多内建函数的返回值。</li>
</ul>
<h3 id="字符串">字符串</h3><h4 id="字符串相加">字符串相加</h4><p>字符串可以由 + 操作符连接(粘到一起)，可以由 * 表示重复<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="prompt">&gt;&gt;&gt; </span><span class="comment"># 3 times 'un', followed by 'ium'</span></span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span><span class="number">3</span> * <span class="string">'un'</span> + <span class="string">'ium'</span></span><br><span class="line"><span class="string">'unununium'</span></span><br></pre></td></tr></table></figure></p>
<h4 id="字符串索引和切片">字符串索引和切片</h4><p>字符串也可以被截取(检索)，类似于 C ，字符串的第一个字符索引为 0 。<br>Python没有单独的字符类型；一个字符就是一个简单的长度为1的字符串。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="prompt">&gt;&gt;&gt; </span>word = <span class="string">'Python'</span></span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span>word[<span class="number">0</span>]  <span class="comment"># character in position 0</span></span><br><span class="line"><span class="string">'P'</span></span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span>word[<span class="number">5</span>]  <span class="comment"># character in position 5</span></span><br><span class="line"><span class="string">'n'</span></span><br></pre></td></tr></table></figure></p>
<p>索引也可以是负数，这将导致从右边开始计算。例如:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="prompt">&gt;&gt;&gt; </span>word[-<span class="number">1</span>]  <span class="comment"># last character</span></span><br><span class="line"><span class="string">'n'</span></span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span>word[-<span class="number">2</span>]  <span class="comment"># second-last character</span></span><br><span class="line"><span class="string">'o'</span></span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span>word[-<span class="number">6</span>]</span><br><span class="line"><span class="string">'P'</span></span><br></pre></td></tr></table></figure></p>
<p><strong>注意 -0 实际上就是 0，所以它不会导致从右边开始计算。</strong><br>除了索引，还支持<em>切片</em>。索引用于获得单个字符，切片让你获得一个子字符串：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="prompt">&gt;&gt;&gt; </span>word = <span class="string">'Python'</span></span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span>word[<span class="number">0</span>:<span class="number">2</span>]  <span class="comment"># characters from position 0 (included) to 2 (excluded)</span></span><br><span class="line"><span class="string">'Py'</span></span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span>word[<span class="number">2</span>:<span class="number">5</span>]  <span class="comment"># characters from position 2 (included) to 5 (excluded)</span></span><br><span class="line"><span class="string">'tho'</span></span><br></pre></td></tr></table></figure></p>
<p>包含起始的字符，不包含末尾的字符。这使得 s[:i] + s[i:] 永远等于 s:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="prompt">&gt;&gt;&gt; </span>word[:<span class="number">2</span>] + word[<span class="number">2</span>:]</span><br><span class="line"><span class="string">'Python'</span></span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span>word[:<span class="number">4</span>] + word[<span class="number">4</span>:]</span><br><span class="line"><span class="string">'Python'</span></span><br></pre></td></tr></table></figure></p>
<p>切片的索引有非常有用的默认值；省略的第一个索引默认为零，省略的第二个索引默认为切片的字符串的大小。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="prompt">&gt;&gt;&gt; </span>word[:<span class="number">2</span>]  <span class="comment"># character from the beginning to position 2 (excluded)</span></span><br><span class="line"><span class="string">'Py'</span></span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span>word[<span class="number">4</span>:]  <span class="comment"># characters from position 4 (included) to the end</span></span><br><span class="line"><span class="string">'on'</span></span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span>word[-<span class="number">2</span>:] <span class="comment"># characters from the second-last (included) to the end</span></span><br><span class="line"><span class="string">'on'</span></span><br></pre></td></tr></table></figure></p>
<p>试图使用太大的索引会导致错误。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="prompt">&gt;&gt;&gt; </span>word[<span class="number">42</span>]  <span class="comment"># the word only has 6 characters</span></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">IndexError: string index out of range</span><br></pre></td></tr></table></figure></p>
<p>Python能够优雅地处理那些没有意义的切片索引：<br><strong>一个过大的索引值(即下标值大于字符串实际长度)将被字符串实际长度所代替，当上边界比下边界大时(即切片左值大于右值)就返回空字符串:</strong><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="prompt">&gt;&gt;&gt; </span>word[<span class="number">4</span>:<span class="number">42</span>]</span><br><span class="line"><span class="string">'on'</span></span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span>word[<span class="number">42</span>:]</span><br><span class="line"><span class="string">''</span></span><br></pre></td></tr></table></figure></p>
<p>Python字符串不可以被更改——它们是<strong>不可变</strong>的。因此，赋值给字符串索引的位置会导致错误:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="prompt">&gt;&gt;&gt; </span>word[<span class="number">0</span>] = <span class="string">'J'</span></span><br><span class="line">  ...</span><br><span class="line">TypeError: <span class="string">'str'</span> object does <span class="keyword">not</span> support item assignment</span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span>word[<span class="number">2</span>:] = <span class="string">'py'</span></span><br><span class="line">  ...</span><br><span class="line">TypeError: <span class="string">'str'</span> object does <span class="keyword">not</span> support item assignment</span><br></pre></td></tr></table></figure></p>
<h4 id="字符串表示，str和repr">字符串表示，str和repr</h4><p>原始的print会显示值在python中的状态<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="prompt">&gt;&gt;&gt; </span><span class="string">"Hello World"</span></span><br><span class="line"><span class="string">'Hello World'</span></span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span><span class="number">10000L</span></span><br><span class="line"><span class="number">10000L</span></span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span><span class="keyword">print</span> <span class="string">"Hello World"</span></span><br><span class="line">Hello World</span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span><span class="keyword">print</span> <span class="number">10000L</span></span><br><span class="line"><span class="number">10000</span></span><br></pre></td></tr></table></figure></p>
<p>实际情况中，可能对一个值的类型感兴趣。</p>
<h5 id="str函数">str函数</h5><p>str函数会把值转换成合理形式的字符串<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="prompt">&gt;&gt;&gt; </span><span class="keyword">print</span> str(<span class="string">"Hello World"</span>)</span><br><span class="line">Hello World</span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span><span class="keyword">print</span> str(<span class="number">10000L</span>)</span><br><span class="line"><span class="number">10000</span></span><br></pre></td></tr></table></figure></p>
<h5 id="repr函数">repr函数</h5><p>repr函数会创建一个字符串，以合法的python表达式的形式来表示值<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="prompt">&gt;&gt;&gt; </span><span class="keyword">print</span> repr(<span class="string">"Hello World"</span>)</span><br><span class="line"><span class="string">'Hello World'</span></span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span><span class="keyword">print</span> repr(<span class="number">10000L</span>)</span><br><span class="line"><span class="number">10000L</span></span><br></pre></td></tr></table></figure></p>
<h5 id="反引号">反引号</h5><p>repr(x)的功能也可以通过<code>x</code>实现（`是反引号，不是单引号）。<br>如果希望打印一个包含数字的句子，反引号就很有用<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="prompt">&gt;&gt;&gt; </span>temp = <span class="number">12</span></span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span><span class="keyword">print</span> <span class="string">"The num is "</span> + `temp`</span><br><span class="line">The num <span class="keyword">is</span> <span class="number">12</span></span><br></pre></td></tr></table></figure></p>
<p>直接用<em>print “The num is” + temp</em>会报错，因为<strong>字符串不可以和数字相加</strong>。</p>
<p>简而言之，str，repr和反引号是将Python值转换成字符串的3种方法。<br>函数str让字符串更容易阅读，而repr和反引号则把结果字符串转换成合法的Python表达式。</p>
<h4 id="input和raw_input">input和raw_input</h4><p>在一个脚本文件中输入以下语句：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">name = input(<span class="string">"What is your name? "</span>)</span><br><span class="line"><span class="keyword">print</span> <span class="string">"Hello, "</span> + name + <span class="string">"!"</span></span><br></pre></td></tr></table></figure></p>
<p>这个程序合法，但input会假设用户输入的是合法的Python表达式，所以，如果用户输入 XXX 就会报错，必须以字符串作为输入 ‘XXX’。<br>如果使用raw_input函数就没问题，它会把所有输入当做原始数据（raw data），将其放入字符串：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="prompt">&gt;&gt;&gt; </span>input(<span class="string">"Enter a number: "</span>)</span><br><span class="line">Enter a number: <span class="number">3</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span>raw_input(<span class="string">"Enter a number: "</span>)</span><br><span class="line">Enter a number: <span class="number">3</span></span><br><span class="line"><span class="string">'3'</span></span><br></pre></td></tr></table></figure></p>
<h4 id="长字符串">长字符串</h4><p>如果需要写一个非常非常长的字符串，需要跨多行，就可以使用三个引号代替普通引号。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">print</span> <span class="string">'''This is a very long string.</span><br><span class="line">It continues here.</span><br><span class="line">And it's not over yet.</span><br><span class="line">"Hello World"</span><br><span class="line">Still here.'''</span></span><br></pre></td></tr></table></figure></p>
<p>也可以使用三个双引号，比如”””Like this”””。<br>注意，可以在字符串中同时使用双引号和单引号，而不需要使用反斜线进行转义。</p>
<h4 id="普通跨行">普通跨行</h4><p>普通字符串也可以跨行，如果一行之中最后一个字符是反斜线，那么，换行符本身就”转义“了，也就是被忽略了。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">print</span> <span class="string">"Hello, \</span><br><span class="line">World!"</span></span><br></pre></td></tr></table></figure></p>
<p>这句会打印Hello World！。<br>这个用法也适用于表达式和语句<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="prompt">&gt;&gt;&gt; </span><span class="number">1</span> + <span class="number">2</span> + \</span><br><span class="line">        <span class="number">4</span> + <span class="number">5</span></span><br><span class="line">        <span class="number">12</span></span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span><span class="keyword">print</span> \</span><br><span class="line">        <span class="string">'Hello, World'</span></span><br><span class="line">Hello World</span><br></pre></td></tr></table></figure></p>
<h4 id="原始字符串">原始字符串</h4><p>原始字符串对反斜线比较友好<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="prompt">&gt;&gt;&gt; </span>path = <span class="string">'C:\nowhere'</span></span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span>path</span><br><span class="line"><span class="string">'C:\nowhere'</span></span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span><span class="keyword">print</span> path</span><br><span class="line">C:</span><br><span class="line">owhere</span><br></pre></td></tr></table></figure></p>
<p>可以使用 <em>\\</em>，但是如果路径很长，就惨了。<br>这个时候，就可以使用原始字符串。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">print</span> <span class="string">r'C:\nowhere'</span></span><br><span class="line">C:\nowhere</span><br></pre></td></tr></table></figure></p>
<p>原始字符串以 r 开头，基本可以认为可以在原始字符串中放入任何字符。<br>但是，<strong>原始字符串最后一个字符不能是反斜线</strong>，因为如果最后一个字符是反斜线，Python就不知道是否应该结束该字符串。<br>如果最后一个字符串需要是反斜线，一个简单的方法是：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="prompt">&gt;&gt;&gt; </span><span class="keyword">print</span> <span class="string">r'C:\Program Files\foo\bar'</span> <span class="string">'\\'</span></span><br><span class="line">C:\Program Files\foo\bar\</span><br></pre></td></tr></table></figure></p>
<h4 id="字符串常用函数">字符串常用函数</h4><ul>
<li>s.lower(), s.upper()</li>
<li>s.strip() —— 移除开头结尾的空格，中间的空格不移除</li>
<li>s.isalpha()/s.isdigit()/s.isspace()</li>
<li>s.startswith(‘other’), s.endswith(‘other’)</li>
<li>s.find(‘other’)</li>
<li>s.replace(‘old’, ‘new’)</li>
<li>s.split(‘delim’) —— ‘aaa,bbb,ccc’.split(‘,’) -&gt; [‘aaa’, ‘bbb’, ‘ccc’]</li>
<li>s.join(list) —— ‘—‘.join([‘aaa’, ‘bbb’, ‘ccc’]) -&gt; aaa—bbb—ccc</li>
</ul>
<h2 id="集合与字典">集合与字典</h2><h3 id="字典">字典</h3><p>字典就是键值对，字典的键可以是任何不可变类型，比如整型，浮点型，字符串或者元组。<br>字典可以通过以下形式创建：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">phonebook = &#123;<span class="string">'Alice'</span> : <span class="string">'2341'</span>, <span class="string">"Beth"</span> : <span class="string">"9102"</span>, <span class="string">"Cecil"</span> : <span class="string">'3258'</span>&#125;</span><br></pre></td></tr></table></figure></p>
<p>可以看到，字典键值之间用 <strong>:</strong>  分隔，项之间用 <strong>,</strong> 分隔，而整个字典则通过一对大括号括起来。<br>字典有个重要特性就是——<strong>自动添加</strong>：一个键在字典中不存在，也可以为其分配一个值，这样字典就会建立新的项。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="prompt">&gt;&gt;&gt; </span>x = []</span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span>x[<span class="number">42</span>] = <span class="string">'Foobar'</span></span><br><span class="line">IndexError: list assignment index out of range</span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span>x = &#123;&#125;</span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span>x[<span class="number">42</span>] = <span class="string">'Foobar'</span></span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span>x</span><br><span class="line">&#123;<span class="number">42</span>: <span class="string">'Foobar'</span>&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="dict函数"><em>dict</em>函数</h4><p><em>dict</em>函数通过其它映射（比如其它字典）或者（键，值）这样的序列来建立字典。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="prompt">&gt;&gt;&gt; </span>items = [(<span class="string">'name'</span>, <span class="string">'Gumby'</span>), (<span class="string">'age'</span>, <span class="number">42</span>)]</span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span>d = dict(items)</span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span>d</span><br><span class="line">&#123;<span class="string">'age'</span>: <span class="number">42</span>, <span class="string">'name'</span>: <span class="string">'Gumby'</span>&#125;</span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span>d[<span class="string">'name'</span>]</span><br><span class="line"><span class="string">'Gumby'</span></span><br></pre></td></tr></table></figure></p>
<p><em>dict</em>函数也可以通过关键字参数来创建字典，比如：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="prompt">&gt;&gt;&gt; </span>d = dict(name=<span class="string">'Gumby'</span>, age=<span class="number">42</span>)</span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span>d</span><br><span class="line">&#123;<span class="string">'age'</span>: <span class="number">42</span>, <span class="string">'name'</span>: <span class="string">'Gumby'</span>&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="字典基本操作">字典基本操作</h4><p>字典的基本操作类似序列，主要包括：</p>
<ul>
<li><em>len(d)</em> 返回键值对的数量</li>
<li><em>d[k]</em> 返回关联到键k上的值</li>
<li><em>d[k] = v</em> 将值v关联到键k上</li>
<li><em>del d[k]</em> 删除键为k的项</li>
<li><em>k in d</em> 检查d中是否有键为k的项</li>
</ul>
<h4 id="字典方法">字典方法</h4><p><em>clear</em><br><em>clear</em>方法清除字典里所有的项。<br>这是一个原地操作，没有返回值，或者说返回None<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="prompt">&gt;&gt;&gt; </span>d = &#123;&#125;</span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span>d[<span class="string">'name'</span>] = <span class="string">'Gumby'</span></span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span>d[<span class="string">'age'</span>] = <span class="number">42</span></span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span>d</span><br><span class="line">&#123;<span class="string">'age'</span>: <span class="number">42</span>, <span class="string">'name'</span>: <span class="string">'Gumby'</span>&#125;</span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span>returned_value = d.clear()</span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span>d</span><br><span class="line">&#123;&#125;</span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span>returned_value</span><br><span class="line"><span class="keyword">None</span></span><br></pre></td></tr></table></figure></p>
<p><em>copy</em><br><em>copy</em>方法实现的是<strong>浅复制</strong>：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="prompt">&gt;&gt;&gt; </span>x = &#123;<span class="string">'username'</span>: <span class="string">'admin'</span>, <span class="string">'machines'</span>: [<span class="string">'foo'</span>, <span class="string">'bar'</span>, <span class="string">'baz'</span>]&#125;</span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span>y = x.copy()</span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span>y[<span class="string">'username'</span>] = <span class="string">'mlh'</span></span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span>y[<span class="string">'machines'</span>].remove(<span class="string">'bar'</span>)</span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span>y</span><br><span class="line">&#123;<span class="string">'username'</span>: <span class="string">'mlh'</span>, <span class="string">'machines'</span>: [<span class="string">'foo'</span>, <span class="string">'baz'</span>]&#125;</span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span>x</span><br><span class="line">&#123;<span class="string">'username'</span>: <span class="string">'admin'</span>, <span class="string">'machines'</span>: [<span class="string">'foo'</span>, <span class="string">'baz'</span>]&#125;</span><br></pre></td></tr></table></figure></p>
<p>可以看到，当在副本里面替换值的时候，原始字典不受影响，但是如果修改了某个值，注意，<strong>原地修改，不是替换</strong>，原始的字典也会改变。因为同样的值也存储在原字典中。<br>避免这个问题的一种方法就是使用<strong>深拷贝</strong>，复制其包含的所有值。使用copy模块的<em>deepcopy</em>函数完成。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="prompt">&gt;&gt;&gt; </span><span class="keyword">from</span> copy <span class="keyword">import</span> deepcopy</span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span>d = &#123;&#125;</span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span>d[<span class="string">'names'</span>] = [<span class="string">'Alfred'</span>, <span class="string">'Beth'</span>]</span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span>c = d.copy()</span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span>dc = d.deepcopy()</span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span>d[<span class="string">'names'</span>].append(<span class="string">'Clive'</span>)</span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span>c</span><br><span class="line">[<span class="string">'Alfred'</span>, <span class="string">'Beth'</span>, <span class="string">'Clive'</span>]</span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span>dc</span><br><span class="line">[<span class="string">'Alfred'</span>, <span class="string">'Beth'</span>]</span><br></pre></td></tr></table></figure></p>
<p><em>fromkeys</em><br><em>fromkeys</em>方法会使用给定的键建立新的字典，每个键默认对应的值为None。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="prompt">&gt;&gt;&gt; </span>&#123;&#125;.fromkeys([<span class="string">'name'</span>, <span class="string">'age'</span>])</span><br><span class="line">&#123;<span class="string">'age'</span>: <span class="keyword">None</span>, <span class="string">'name'</span>: <span class="keyword">None</span>&#125;</span><br></pre></td></tr></table></figure></p>
<p>也可以提供自己的默认值<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="prompt">&gt;&gt;&gt; </span>&#123;&#125;.fromkeys([<span class="string">'name'</span>, <span class="string">'age'</span>], <span class="string">'unknown'</span>)</span><br><span class="line">&#123;<span class="string">'age'</span>: <span class="string">'unknown'</span>, <span class="string">'name'</span>: <span class="string">'unknown'</span>&#125;</span><br></pre></td></tr></table></figure></p>
<p><em>get</em><br><em>get</em>方法用来访问字典，它的作用是，如果试图访问字典中不存在的项也不会报错<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="prompt">&gt;&gt;&gt; </span>d = &#123;&#125;</span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span><span class="keyword">print</span> d[<span class="string">'name'</span>]</span><br><span class="line">KeyError: <span class="string">'name'</span></span><br></pre></td></tr></table></figure></p>
<p>而用get就不会<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="prompt">&gt;&gt;&gt; </span><span class="keyword">print</span> d.get(<span class="string">'name'</span>)</span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span><span class="keyword">None</span></span><br></pre></td></tr></table></figure></p>
<p>可以看到，用get访问一个不存在的键时，没有任何异常，得到的是None值。<br>还可以自定义默认值，替换None：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="prompt">&gt;&gt;&gt; </span>d.get(<span class="string">'name'</span>, <span class="string">'N/A'</span>)</span><br><span class="line"><span class="string">'N/A'</span></span><br></pre></td></tr></table></figure></p>
<p>如果键存在，get用起来跟普通的字典查询一样。</p>
<p><em>has_key</em><br>has_key用来检查字典中是否含有给出的键。<br>表达式d.has_key(k)相当于表达式<em>k in d</em>。<br>使用方式取决于个人喜好，但是注意，<strong>python3.0中不包含这个函数</strong>。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="prompt">&gt;&gt;&gt; </span>d = &#123;&#125;</span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span>d.has_key(<span class="string">'name'</span>)</span><br><span class="line"><span class="keyword">False</span></span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span>d[<span class="string">'name'</span>] = <span class="string">'Eric'</span></span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span>d.has_key(<span class="string">'name'</span>)</span><br><span class="line"><span class="keyword">True</span></span><br></pre></td></tr></table></figure></p>
<p><em>items</em>和<em>iteritems</em><br><em>items</em>方法将字典以列表方式返回，但返回时没有特殊顺序。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="prompt">&gt;&gt;&gt; </span>d = &#123;<span class="string">'title'</span>: <span class="string">'Python Web Site'</span>, <span class="string">'url'</span>: <span class="string">'http://www.python.org'</span>, <span class="string">'spam'</span>: <span class="number">0</span>&#125;</span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span>d.items()</span><br><span class="line">[(<span class="string">'url'</span>, <span class="string">'http://www.python.org'</span>), (<span class="string">'spam'</span>, <span class="number">0</span>), (<span class="string">'title'</span>, <span class="string">'Python Web Site'</span>)]</span><br></pre></td></tr></table></figure></p>
<p><em>iteritems</em>返回一个<strong>迭代器对象</strong>而不是列表：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="prompt">&gt;&gt;&gt; </span>it = d.iteritems()</span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span>it</span><br><span class="line">&lt;dictionary-itemiterator object at <span class="number">0x10e4e2788</span>&gt;</span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span>list(it) <span class="comment"># Convert the iterator to a list</span></span><br><span class="line">[(<span class="string">'url'</span>, <span class="string">'http://www.python.org'</span>), (<span class="string">'spam'</span>, <span class="number">0</span>), (<span class="string">'title'</span>, <span class="string">'Python Web Site'</span>)]</span><br></pre></td></tr></table></figure></p>
<p><em>keys</em>和<em>iterkeys</em><br>同上，只是返回的是键</p>
<h5 id="values和itervalues"><em>values</em>和<em>itervalues</em></h5><p>同上，以列表形式返回值，但是与返回键不同，返回值的列表中可以包含重复的元素。</p>
<p><em>pop</em><br><em>pop</em>用来获得给定键对应的值，同时将键值对从字典中移除<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="prompt">&gt;&gt;&gt; </span>d = &#123;<span class="string">'x'</span>: <span class="number">1</span>, <span class="string">'y'</span>: <span class="number">2</span>&#125;</span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span>d.pop(<span class="string">'x'</span>)</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span>d</span><br><span class="line">&#123;<span class="string">'y'</span>: <span class="number">2</span>&#125;</span><br></pre></td></tr></table></figure></p>
<p><em>popitem</em><br><em>popitem</em>方法类似于list.pop，后者会弹出列表的最后一个元素，但不同的是，popitem弹出随机的项，因为字典没有“最后的元素”或者相关顺序的概念。<br>若想一个接一个的移除并处理项，这个方法就很有用。</p>
<p><em>update</em><br><em>update</em>方法会利用一个字典去更新另一个字典。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="prompt">&gt;&gt;&gt; </span>d = &#123;<span class="string">'name'</span>: <span class="string">'Alice'</span>, <span class="string">'age'</span>: <span class="number">21</span>&#125;</span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span>x = &#123;<span class="string">'name'</span>: <span class="string">'Beth'</span>, <span class="string">'home'</span>: <span class="string">'China'</span>&#125;</span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span>d.update(x)</span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span>d</span><br><span class="line">&#123;<span class="string">'home'</span>: <span class="string">'China'</span>, <span class="string">'age'</span>: <span class="number">21</span>, <span class="string">'name'</span>: <span class="string">'Beth'</span>&#125;</span><br></pre></td></tr></table></figure></p>
<p>可以看到，提供的字典中的项会被添加到旧的字典中，若有相同的键则会覆盖。</p>
<h3 id="集合">集合</h3><p>Python的Set跟其他语言类似，就是一个无序不重复数组。<br>作为一个无序的集合，Set不记录元素的插入位置或者插入点。<br>想要创建空集合，你必须使用 <em>set()</em> 而不是 <em>{}</em>。后者用于创建空字典。<br>一些例子如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="prompt">&gt;&gt;&gt; </span>basket = [<span class="string">'apple'</span>, <span class="string">'orange'</span>, <span class="string">'apple'</span>, <span class="string">'pear'</span>, <span class="string">'orange'</span>, <span class="string">'banana'</span>]</span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span>fruit = set(basket)               <span class="comment"># create a set without duplicates</span></span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span>fruit</span><br><span class="line">set([<span class="string">'orange'</span>, <span class="string">'pear'</span>, <span class="string">'apple'</span>, <span class="string">'banana'</span>])</span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span><span class="string">'orange'</span> <span class="keyword">in</span> fruit                 <span class="comment"># fast membership testing</span></span><br><span class="line"><span class="keyword">True</span></span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span><span class="string">'crabgrass'</span> <span class="keyword">in</span> fruit</span><br><span class="line"><span class="keyword">False</span></span><br><span class="line"></span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span><span class="comment"># Demonstrate set operations on unique letters from two words</span></span><br><span class="line">...</span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span>a = set(<span class="string">'abracadabra'</span>)</span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span>b = set(<span class="string">'alacazam'</span>)</span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span>a                                  <span class="comment"># unique letters in a</span></span><br><span class="line">set([<span class="string">'a'</span>, <span class="string">'r'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'d'</span>])</span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span>a - b                              <span class="comment"># letters in a but not in b</span></span><br><span class="line">set([<span class="string">'r'</span>, <span class="string">'d'</span>, <span class="string">'b'</span>])</span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span>a | b                              <span class="comment"># letters in either a or b</span></span><br><span class="line">set([<span class="string">'a'</span>, <span class="string">'c'</span>, <span class="string">'r'</span>, <span class="string">'d'</span>, <span class="string">'b'</span>, <span class="string">'m'</span>, <span class="string">'z'</span>, <span class="string">'l'</span>])</span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span>a &amp; b                              <span class="comment"># letters in both a and b</span></span><br><span class="line">set([<span class="string">'a'</span>, <span class="string">'c'</span>])</span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span>a ^ b                              <span class="comment"># letters in a or b but not both</span></span><br><span class="line">set([<span class="string">'r'</span>, <span class="string">'d'</span>, <span class="string">'b'</span>, <span class="string">'m'</span>, <span class="string">'z'</span>, <span class="string">'l'</span>])</span><br></pre></td></tr></table></figure></p>
<h4 id="集合基本操作">集合基本操作</h4><ul>
<li>len(s)<br>set 的长度 </li>
<li>x in s<br>测试 x 是否是 s 的成员</li>
<li>x not in s<br>测试 x 是否不是 s 的成员  </li>
<li>s.issubset(t) 或者 s &lt;= t<br>测试是否 s 中的每一个元素都在 t 中</li>
<li>s.issuperset(t) 或者 s &gt;= t<br>测试是否 t 中的每一个元素都在 s 中  </li>
<li>s.union(t) 或者 s | t<br>返回一个新的 set 包含 s 和 t 中的每一个元素  </li>
<li>s.intersection(t) 或者 s &amp; t<br>返回一个新的 set 包含 s 和 t 中的公共元素  </li>
<li>s.difference(t) 或者 s - t<br>返回一个新的 set 包含 s 中有但是 t 中没有的元素 </li>
<li>s.symmetric_difference(t) 或者 s ^ t<br>返回一个新的 set 包含 s 和 t 中不重复的元素 </li>
<li>s.copy()<br>返回 set “s”的一个浅复制  </li>
<li>s.update(t) 或者 s |= t<br>返回增加了 set “t”中元素后的 set “s”  </li>
<li>s.intersection_update(t) 或者 s &amp;= t<br>返回只保留含有 set “t”中元素的 set “s”  </li>
<li>s.difference_update(t) 或者 s -= t<br>返回删除了 set “t”中含有的元素后的 set “s”  </li>
<li>s.symmetric_difference_update(t) 或者 s ^= t<br>返回含有 set “t”或者 set “s”中有而不是两者都有的元素的 set “s”  </li>
<li>s.add(x)<br>向 set “s”中增加元素 x </li>
<li>s.remove(x)<br>从 set “s”中删除元素 x, 如果不存在则引发 KeyError </li>
<li>s.discard(x)<br>如果在 set “s”中存在元素 x, 则删除</li>
<li>s.pop()<br>删除并且返回 set “s”中的一个不确定的元素, 如果为空则引发 KeyError </li>
<li>s.clear()<br>删除 set “s”中的所有元素 </li>
</ul>
<h2 id="语句">语句</h2><h3 id="import">import</h3><p>从模块中导入函数，一般可以这样：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> somemodule</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> somemodule <span class="keyword">import</span> somefunction</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> somemodule <span class="keyword">import</span> somefunction, anotherfunction</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> somemodule <span class="keyword">import</span> *</span><br></pre></td></tr></table></figure></p>
<p>如果两个模块都含有同一个函数，比如<em>open()</em>，就要使用第一种，然后：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">module1.open()</span><br><span class="line">module2.open()</span><br></pre></td></tr></table></figure></p>
<p>还可以使用<em>as</em>语句，为模块提供别名：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="prompt">&gt;&gt;&gt; </span><span class="keyword">import</span> math <span class="keyword">as</span> foobar</span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span>foobar.sqrt(<span class="number">4</span>)</span><br><span class="line"><span class="number">2.0</span></span><br></pre></td></tr></table></figure></p>
<p>除了为模块提供别名，还可以为函数提供别名：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="prompt">&gt;&gt;&gt; </span><span class="keyword">from</span> math <span class="keyword">import</span> sqrt <span class="keyword">as</span> foobar</span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span>foobar(<span class="number">4</span>)</span><br><span class="line"><span class="number">2.0</span></span><br></pre></td></tr></table></figure></p>
<p>所以回到上面的两个模块都含有<em>open()</em>函数的情况，就可以这样：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> module1 <span class="keyword">import</span> open <span class="keyword">as</span> open1</span><br><span class="line"><span class="keyword">from</span> module2 <span class="keyword">import</span> open <span class="keyword">as</span> open2</span><br></pre></td></tr></table></figure></p>
<h3 id="赋值">赋值</h3><h4 id="序列解包">序列解包</h4><p>赋值操作可以多个同时进行<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="prompt">&gt;&gt;&gt; </span>x, y, z = <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span></span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span><span class="keyword">print</span> x, y, z</span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span></span><br></pre></td></tr></table></figure></p>
<p>也可以交换两个（或者多个）变量<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="prompt">&gt;&gt;&gt; </span>x, y = y, x</span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span><span class="keyword">print</span> x, y, z</span><br><span class="line"><span class="number">2</span> <span class="number">1</span> <span class="number">3</span></span><br></pre></td></tr></table></figure></p>
<p>这种行为叫做<strong>序列解包</strong>，或<strong>可迭代解包</strong>——将多个值的序列解开，然后放到变量的序列中。<br>更形象一点就是：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="prompt">&gt;&gt;&gt; </span>value = <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span></span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span>value</span><br><span class="line">(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span>x, y, z = values</span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span>x</span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure></p>
<p>当函数返回元组（或者其他序列或可迭代对象）时，这个特性就非常有用了。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="prompt">&gt;&gt;&gt; </span>scoundrel = &#123;<span class="string">'name'</span>: <span class="string">'Robin'</span>, <span class="string">'girlfriend'</span>: <span class="string">'Marion'</span>&#125;</span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span>key, value = scoundrel.popitem()</span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span>key</span><br><span class="line"><span class="string">'girlfriend'</span></span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span>value</span><br><span class="line"><span class="string">'Marion'</span></span><br></pre></td></tr></table></figure></p>
<p>可以看到，<em>popitem()</em>会获取字典中任意的键值对并返回，然后这个元组正好赋值给了我们的两个变量。<br><strong>注意，所解包序列中的元素数量必须和放置在赋值符号=左边的变量数量完全一致，否则会抛异常。</strong></p>
<h4 id="链式赋值">链式赋值</h4><p><strong>链式赋值</strong>可以将同一个值赋给多个变量。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x = y = function()</span><br></pre></td></tr></table></figure></p>
<h4 id="增量赋值">增量赋值</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="prompt">&gt;&gt;&gt; </span>x = <span class="number">2</span></span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span>x += <span class="number">1</span></span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span>x *= <span class="number">2</span></span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span>x</span><br><span class="line"><span class="number">6</span></span><br><span class="line"></span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span>s = <span class="string">'foo'</span></span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span>s += <span class="string">'bar'</span></span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span>s *= <span class="number">2</span></span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span>s</span><br><span class="line"><span class="string">'foobarfoobar'</span></span><br></pre></td></tr></table></figure>
<h3 id="条件语句">条件语句</h3><h4 id="布尔变量">布尔变量</h4><p>下面这些值作为布尔表达式的时候，会被解释器看做假（false）：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">False</span>  <span class="keyword">None</span>  <span class="number">0</span>  <span class="string">''</span>  ()  []  &#123;&#125;</span><br></pre></td></tr></table></figure></p>
<p>除此之外的一切都会被解释为真。<br>因为所有值都可以作为布尔类型，所以几乎不需要对它们进行显式转换。</p>
<h3 id="循环语句">循环语句</h3><h4 id="for语句">for语句</h4><p>Python中的<em>for</em>语句和 C 或 Pascal 中的略有不同。通常的循环可能会依据一个等差数值步进过程(如Pascal)，或由用户来定义迭代步骤和中止条件(如C)，Python的<em>for</em>语句依据任意序列(链表或字符串)中的子项，按它们在序列中的顺序来进行迭代，例如：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="prompt">&gt;&gt;&gt; </span><span class="comment"># Measure some strings:</span></span><br><span class="line"><span class="prompt">... </span>words = [<span class="string">'cat'</span>, <span class="string">'window'</span>, <span class="string">'defenestrate'</span>]</span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span><span class="keyword">for</span> w <span class="keyword">in</span> words:</span><br><span class="line"><span class="prompt">... </span>    <span class="keyword">print</span> w, len(w)</span><br><span class="line">...</span><br><span class="line">cat <span class="number">3</span></span><br><span class="line">window <span class="number">6</span></span><br><span class="line">defenestrate <span class="number">12</span></span><br></pre></td></tr></table></figure></p>
<h4 id="range函数"><em>range</em>函数</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="prompt">&gt;&gt;&gt; </span>range(<span class="number">10</span>)</span><br><span class="line">[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]</span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span>range(<span class="number">5</span>, <span class="number">10</span>)</span><br><span class="line">[<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]</span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span>range(<span class="number">0</span>, <span class="number">10</span>, <span class="number">3</span>)</span><br><span class="line">[<span class="number">0</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">9</span>]</span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span>range(-<span class="number">10</span>, -<span class="number">100</span>, -<span class="number">30</span>)</span><br><span class="line">[-<span class="number">10</span>, -<span class="number">40</span>, -<span class="number">70</span>]</span><br></pre></td></tr></table></figure>
<p>需要迭代链表索引的话，如下所示结合使用<em>range()</em>和<em>len()</em>：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="prompt">&gt;&gt;&gt; </span>a = [<span class="string">'Mary'</span>, <span class="string">'had'</span>, <span class="string">'a'</span>, <span class="string">'little'</span>, <span class="string">'lamb'</span>]</span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span><span class="keyword">for</span> i <span class="keyword">in</span> range(len(a)):</span><br><span class="line"><span class="prompt">... </span>    <span class="keyword">print</span> i, a[i]</span><br><span class="line">...</span><br><span class="line"><span class="number">0</span> Mary</span><br><span class="line"><span class="number">1</span> had</span><br><span class="line"><span class="number">2</span> a</span><br><span class="line"><span class="number">3</span> little</span><br><span class="line"><span class="number">4</span> lamb</span><br></pre></td></tr></table></figure></p>
<h4 id="一些迭代">一些迭代</h4><h5 id="并行迭代">并行迭代</h5><p>同时迭代两个序列可以如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">names = [<span class="string">'anne'</span>, <span class="string">'beth'</span>, <span class="string">'george'</span>, <span class="string">'damon'</span>]</span><br><span class="line">ages = [<span class="number">12</span>, <span class="number">45</span>, <span class="number">32</span>, <span class="number">102</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(names)):</span><br><span class="line">    <span class="keyword">print</span> names[i], <span class="string">'is'</span>, ages[i], <span class="string">'years old'</span></span><br></pre></td></tr></table></figure></p>
<p>这里的<strong>i</strong>是循环索引的标准变量名。<br>内建的<em>zip</em>函数可以用来进行并行迭代，将两个序列“压缩”起来，然后返回一个元组的列表：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="prompt">&gt;&gt;&gt; </span>zip(names, ages)</span><br><span class="line">[(<span class="string">'anne'</span>, <span class="number">12</span>), (<span class="string">'beth'</span>, <span class="number">45</span>), (<span class="string">'george'</span>, <span class="number">32</span>), (<span class="string">'damon'</span>, <span class="number">102</span>)]</span><br></pre></td></tr></table></figure></p>
<p>现在可以在循环中解包元组：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> name, age <span class="keyword">in</span> zip(names, ages):</span><br><span class="line">    <span class="keyword">print</span> name, <span class="string">'is'</span>, age, <span class="string">'years old'</span></span><br></pre></td></tr></table></figure></p>
<p><em>zip</em>函数可以作用于任意多的序列。<br>重要的是，<strong>zip函数可以用于不等长的序列，结束时机是最短序列结束</strong>。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="prompt">&gt;&gt;&gt; </span>zip(range(<span class="number">5</span>), xrange(<span class="number">1000000000</span>))</span><br><span class="line">[(<span class="number">0</span>, <span class="number">0</span>), (<span class="number">1</span>, <span class="number">1</span>), (<span class="number">2</span>, <span class="number">2</span>), (<span class="number">3</span>, <span class="number">3</span>), (<span class="number">4</span>, <span class="number">4</span>)]</span><br></pre></td></tr></table></figure></p>
<p>在上面的示例中，range会计算所有数字，但是xrange只会计算前五个。</p>
<h5 id="编号迭代">编号迭代</h5><p>有的时候想要迭代序列中的对象，同时还要获取当前对象的索引。<br>例如，在一个字符串列表中替换所有包含’xxx’的子字符串。<br>一般想到的方法如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> string <span class="keyword">in</span> strings:</span><br><span class="line">    <span class="keyword">if</span> <span class="string">'xxx'</span> <span class="keyword">in</span> string:</span><br><span class="line">        index = strings.index(string) <span class="comment"># search for the string in the list of strings</span></span><br><span class="line">        strings[index] = <span class="string">'[censored]'</span></span><br></pre></td></tr></table></figure></p>
<p>上面这段代码，替换前要搜索给定的字符串似乎没有必要。<br>一个比较好的版本是：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">index = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> string <span class="keyword">in</span> strings:</span><br><span class="line">    <span class="keyword">if</span> <span class="string">'xxx'</span> <span class="keyword">in</span> string:</span><br><span class="line">        strings[index] = <span class="string">'[censored]'</span></span><br><span class="line">    index++;</span><br></pre></td></tr></table></figure></p>
<p>这个方法有点笨，但是可以被接受。<br>更好的方法是使用内建的<em>enumerate</em>函数：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> index, string <span class="keyword">in</span> enumerate(strings):</span><br><span class="line">    <span class="keyword">if</span> <span class="string">'xxx'</span> <span class="keyword">in</span>  string:</span><br><span class="line">        strings[index] = <span class="string">'[censored]'</span></span><br></pre></td></tr></table></figure></p>
<h5 id="翻转和排序迭代">翻转和排序迭代</h5><p>看看另外两个有用的函数：<em>reversed</em>和<em>sorted</em>：它们同列表的reverse和sort方法类似，但作用于任何排序或可迭代对象上，不是原地修改对象，而是返回翻转或排序后的版本。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="prompt">&gt;&gt;&gt; </span>sorted([<span class="number">4</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">3</span>])</span><br><span class="line">[<span class="number">3</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>]</span><br></pre></td></tr></table></figure></p>
<h2 id="函数">函数</h2><h3 id="定义函数">定义函数</h3><p>定义函数可以使用<em>def</em>语句：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fibs</span><span class="params">(num)</span>:</span></span><br><span class="line">    result = [<span class="number">0</span>, <span class="number">1</span>]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(num - <span class="number">2</span>):</span><br><span class="line">        result.append(result[-<span class="number">2</span>] + result[-<span class="number">1</span>])</span><br><span class="line">    <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure></p>
<p>执行了这段语句后，编译器就知道如何计算斐波那契数列了.<br>现在不需要关注细节，只要用函数fibs就行了。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="prompt">&gt;&gt;&gt; </span>fibs(<span class="number">10</span>)</span><br><span class="line">[<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">13</span>, <span class="number">21</span>, <span class="number">34</span>]</span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span>fibs(<span class="number">15</span>)</span><br><span class="line">[<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">13</span>, <span class="number">21</span>, <span class="number">34</span>, <span class="number">55</span>, <span class="number">89</span>, <span class="number">144</span>, <span class="number">233</span>, <span class="number">377</span>]</span><br></pre></td></tr></table></figure></p>
<h4 id="函数文档">函数文档</h4><p>如果在函数的开头写下字符串，就会作为函数的一部分进行存储，这称为<strong>文档字符串</strong>。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">square</span><span class="params">(x)</span>:</span></span><br><span class="line">    <span class="string">'Calculates the square of the number x.'</span></span><br><span class="line">    <span class="keyword">return</span> x * x</span><br></pre></td></tr></table></figure></p>
<p>文档字符串可以按如下方式访问：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="prompt">&gt;&gt;&gt; </span>square.__doc__</span><br><span class="line"><span class="string">'Calculates the square of the number x.'</span></span><br></pre></td></tr></table></figure></p>
<p><em>__doc__</em>是函数属性，属性名中的双下划线表示其为一个特殊属性。</p>
<h3 id="函数参数">函数参数</h3><h4 id="参数是否可变？">参数是否可变？</h4><p>函数通过其参数获取一系列的值，那这些值能改变吗？<br>先看这种情况：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="prompt">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">try_to_change</span><span class="params">(n)</span>:</span></span><br><span class="line">        n = <span class="string">'Mr. Gumby'</span></span><br><span class="line"></span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span>name = <span class="string">'Mrs. Entity'</span></span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span>try_to_change(name)</span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span>name</span><br><span class="line"><span class="string">'Mrs. Entity'</span></span><br></pre></td></tr></table></figure></p>
<p>参数存储在<strong>局部作用域</strong>中。<br>在try_to_change内，参数n获取了新值，但是这并没有影响到name变量。<br>n实际上是一个完全不同的变量，具体工作方式类似于：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="prompt">&gt;&gt;&gt; </span>name = <span class="string">'Mrs. Entity'</span></span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span>n = name <span class="comment"># 这句话基本相当于传参</span></span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span>n = <span class="string">'Mr. Gumby'</span> <span class="comment"># 在函数内部完成</span></span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span>name</span><br><span class="line"><span class="string">'Mrs. Entity'</span></span><br></pre></td></tr></table></figure></p>
<p>结果显然是改变n的时候，变量name不变。<br>字符串是不可变的，但如果参数是可变的数据结构如列表的时候呢？<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="prompt">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">change</span><span class="params">(n)</span>:</span></span><br><span class="line">        n[<span class="number">0</span>] = <span class="string">'Mr. Gumby'</span></span><br><span class="line"></span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span>names = [<span class="string">'Mrs. Entity'</span>, <span class="string">'Mrs. Thing'</span>]</span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span>change(names)</span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span>names</span><br><span class="line">[<span class="string">'Mr. Gumby'</span>, <span class="string">'Mrs. Thing'</span>]</span><br></pre></td></tr></table></figure></p>
<p>为什么呢？不用函数模拟一次：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="prompt">&gt;&gt;&gt; </span>names = [<span class="string">'Mrs. Entity'</span>, <span class="string">'Mrs. Thing'</span>]</span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span>n = names <span class="comment"># 模拟传参</span></span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span>n[<span class="number">0</span>] = <span class="string">'Mr. Gumby'</span></span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span>names</span><br><span class="line">[<span class="string">'Mr. Gumby'</span>, <span class="string">'Mrs. Thing'</span>]</span><br></pre></td></tr></table></figure></p>
<p>所以实际情况就是两个变量同时引用了一个列表。<br>为了避免这种情况，可以复制一个列表的<strong>副本</strong>。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="prompt">&gt;&gt;&gt; </span>change(names[:])</span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span>names</span><br><span class="line">[<span class="string">'Mrs. Entity'</span>, <span class="string">'Mrs. Thing'</span>]</span><br></pre></td></tr></table></figure></p>
<h4 id="关键字参数和默认值">关键字参数和默认值</h4><p>前面提到的参数都是<strong>位置参数</strong>，其位置比其名字更加重要。<br>考虑下面两个函数：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hello_1</span><span class="params">(greeting, name)</span>:</span></span><br><span class="line">    <span class="keyword">print</span> <span class="string">'%s, %s!'</span> % (greeting, name)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hello_2</span><span class="params">(name, greeting)</span>:</span></span><br><span class="line">    <span class="keyword">print</span> <span class="string">'%s, %s!'</span> % (name, greeting)</span><br></pre></td></tr></table></figure></p>
<p>这两个函数只是参数名字反过来了，实现的功能是完全一样的。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="prompt">&gt;&gt;&gt; </span>hello_1(<span class="string">'Hello'</span>, <span class="string">'World'</span>)</span><br><span class="line">Hello, World!</span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span>hello_2(<span class="string">'Hello'</span>, <span class="string">'World'</span>)</span><br><span class="line">Hello, World!</span><br></pre></td></tr></table></figure></p>
<p>有些时候，参数的顺序很难记住，简单起见，可以提供参数的名字。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="prompt">&gt;&gt;&gt; </span>hello_1(greeting=<span class="string">'Hello'</span>, name=<span class="string">'World'</span>)</span><br><span class="line">Hello, World!</span><br></pre></td></tr></table></figure></p>
<p>这样的话，参数的位置也就是顺序就没影响了：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="prompt">&gt;&gt;&gt; </span>hello_1(name=<span class="string">'World'</span>, greeting=<span class="string">'Hello'</span>)</span><br><span class="line">Hello, World!</span><br></pre></td></tr></table></figure></p>
<p>不过要注意参数名和值一定要对应<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="prompt">&gt;&gt;&gt; </span>hello_2(greeting=<span class="string">'Hello'</span>, name=<span class="string">'World'</span>)</span><br><span class="line">World, Hello!</span><br></pre></td></tr></table></figure></p>
<p>这类使用参数名提供的参数叫做<strong>关键字参数</strong>。<br>其主要作用是明确每个参数的作用，避免让人不知所云的函数调用。<br>而且即使弄乱了参数的顺序，也不会影响程序的功能。<br>当然，关键字参数最强大的功能还是<strong>为参数提供默认值</strong>。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hello_3</span><span class="params">(greeting=<span class="string">'Hello'</span>, name=<span class="string">'World'</span>)</span>:</span></span><br><span class="line">    <span class="keyword">print</span> <span class="string">'%s, %s!'</span> % (greeting, name)</span><br></pre></td></tr></table></figure></p>
<p>当参数有默认值的时候，调用的时候，就可以<strong>不提供、提供一些、提供全部</strong>参数。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="prompt">&gt;&gt;&gt; </span>hello_3()</span><br><span class="line">Hello, World!</span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span>hello_3(<span class="string">'Greetings'</span>)</span><br><span class="line">Greetings, World!</span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span>hello_3(<span class="string">'Greeting'</span>, <span class="string">'Universe'</span>)</span><br><span class="line">Greeting, Universe!</span><br></pre></td></tr></table></figure></p>
<p>如果只想给name提供参数，而greeting使用默认值该怎么办？<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="prompt">&gt;&gt;&gt; </span>hello_3(name=<span class="string">'Gumby'</span>)</span><br><span class="line">Hello, Gumby!</span><br></pre></td></tr></table></figure></p>
<p>位置参数和关键字参数甚至可以联合使用，但是要注意，<strong>要将位置参数放置在前面</strong>，否则解释器会分不清。</p>
<h4 id="收集参数">收集参数</h4><p>如果要给函数提供任意多的参数，可以这样定义函数：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">print_params</span><span class="params">(*params)</span>:</span></span><br><span class="line">    <span class="keyword">print</span> params</span><br></pre></td></tr></table></figure></p>
<p>这边用了一个星号，看看调用这个函数会出现什么情况。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="prompt">&gt;&gt;&gt; </span>print_params(<span class="string">'Testing'</span>)</span><br><span class="line">(<span class="string">'Testing'</span>,)</span><br></pre></td></tr></table></figure></p>
<p>可以看到结果是一个元组，因为有一个逗号。<br>再看看传入多个参数：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="prompt">&gt;&gt;&gt; </span>print_params(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line">(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br></pre></td></tr></table></figure></p>
<p>可以看到参数前的星号将所有值放置到了一个元组中，也可以认为是将参数收集了起来，然后使用。<br>看看能不能联合普通参数：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">print_params_2</span><span class="params">(title, *parmas)</span>:</span></span><br><span class="line">    <span class="keyword">print</span> title</span><br><span class="line">    <span class="keyword">print</span> params</span><br></pre></td></tr></table></figure></p>
<p>试着调用这个函数：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="prompt">&gt;&gt;&gt; </span>print_params_2(<span class="string">'Params'</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line">Params</span><br><span class="line">(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br></pre></td></tr></table></figure></p>
<p>所以星号就可以理解为“收集其余的位置参数”。<br>如果不提供任何可供收集的元素，params就是一个空元组。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="prompt">&gt;&gt;&gt; </span>print_params_2(<span class="string">'Nothing'</span>)</span><br><span class="line">Nothing</span><br><span class="line">()</span><br></pre></td></tr></table></figure></p>
<p>但能不能联合使用关键字参数呢？<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="prompt">&gt;&gt;&gt; </span>print_params_2(<span class="string">'Hmm...'</span>, something=<span class="number">42</span>)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">TypeError: print_params_2() got an unexpected keyword argument <span class="string">'something'</span></span><br></pre></td></tr></table></figure></p>
<p>看来不行，那么如果需要处理关键字参数的“收集”操作该怎么办？<br>会不会是“**”？<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">print_params_3</span><span class="params">(**params)</span>:</span></span><br><span class="line">    <span class="keyword">print</span> params</span><br></pre></td></tr></table></figure></p>
<p>解释器没有报错，调用一下看看：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="prompt">&gt;&gt;&gt; </span>print_params_3(x=<span class="number">1</span>, y=<span class="number">2</span>, z=<span class="number">3</span>)</span><br><span class="line">&#123;<span class="string">'y'</span>: <span class="number">2</span>, <span class="string">'x'</span>: <span class="number">1</span>, <span class="string">'z'</span>: <span class="number">3</span>&#125;</span><br></pre></td></tr></table></figure></p>
<p>返回的是字典而不是元组。<br>那联合别的参数看看：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">print_params_4</span><span class="params">(x, y, z=<span class="number">3</span>, *pospar, **keypar)</span>:</span></span><br><span class="line">    <span class="keyword">print</span> x, y, z</span><br><span class="line">    <span class="keyword">print</span> pospar</span><br><span class="line">    <span class="keyword">print</span> keypar</span><br></pre></td></tr></table></figure></p>
<p>调用看看：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="prompt">&gt;&gt;&gt; </span>print_params_4(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, foo=<span class="number">1</span>, bar=<span class="number">2</span>)</span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span></span><br><span class="line">(<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>)</span><br><span class="line">&#123;<span class="string">'foo'</span>: <span class="number">1</span>, <span class="string">'bar'</span>: <span class="number">2</span>&#125;</span><br></pre></td></tr></table></figure></p>
<p>可以看到，正是我们想要的结果。</p>
<h4 id="分发参数">分发参数</h4><p>加入有下面这个函数：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(x, y)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> x + y</span><br></pre></td></tr></table></figure></p>
<p>如果我们想将有两个要相加的数组组成的元组作为参数，该如何使用？<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="prompt">&gt;&gt;&gt; </span>params = (<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span>add(*params)</span><br><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure></p>
<p>也可以用同样的技术来处理字典——使用**运算符。<br>记得前面定义的<em>hello_3</em>函数<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="prompt">&gt;&gt;&gt; </span>params = &#123;<span class="string">'name'</span>: <span class="string">'Sir Robin'</span>, <span class="string">'greeting'</span>: <span class="string">'Well met'</span>&#125;</span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span>hello_3(**params)</span><br><span class="line">Well met, Sir Robin!</span><br></pre></td></tr></table></figure></p>
<p>回想一下，可能与原始的参数调用混淆：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="prompt">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">with_star</span><span class="params">(**kwds)</span>:</span></span><br><span class="line">    <span class="keyword">print</span> kwds[<span class="string">'name'</span>], <span class="string">'is'</span>, kwds[<span class="string">'age'</span>], <span class="string">'years old'</span></span><br><span class="line"></span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">without_star</span><span class="params">(kwds)</span>:</span></span><br><span class="line">    <span class="keyword">print</span> kwds[<span class="string">'name'</span>], <span class="string">'is'</span>, kwds[<span class="string">'age'</span>], <span class="string">'years old'</span></span><br><span class="line"></span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span>args = &#123;<span class="string">'name'</span>: <span class="string">'Mr. Aber'</span>, <span class="string">'age'</span>: <span class="number">42</span>&#125;</span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span>with_star(**args)</span><br><span class="line">Mr. Aber <span class="keyword">is</span> <span class="number">42</span> years old</span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span>without_star(args)</span><br><span class="line">Mr. Aber <span class="keyword">is</span> <span class="number">42</span> years old</span><br></pre></td></tr></table></figure></p>
<p>可以看到，<em>with_star()</em>函数在定义和调用的时候都用到了星号，得到的结果同自始至终没用到星号的<em>without_star()</em>相同。<br>所以星号只在定义函数（允许使用不定数目的参数）或者调用（“分割”字典或者序列）时才有用。</p>
<h3 id="作用域">作用域</h3><p>除了全局作用域，每个函数的调用都会创建一个新的作用域。<br>函数内的变量称为<strong>局部变量</strong>。<br>一般来说，函数内部，可以直接读取全局变量。<br>但是，如果局部变量或者参数与想访问的全部变量同名的话，就不行了。全局变量会被屏蔽。<br>如果需要用全局变量的话，就要使用globals函数获取全局变量值，它可以返回全局变量的字典。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="prompt">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">combine</span><span class="params">(param)</span>:</span></span><br><span class="line">    <span class="keyword">print</span> param + globals()[<span class="string">'param'</span>]</span><br><span class="line"></span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span>param = <span class="string">'berry'</span></span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span>combine(<span class="string">'Shrub'</span>)</span><br><span class="line">Shrubberry</span><br></pre></td></tr></table></figure></p>
<p>如果在函数内部定义一个变量，它会自动成为局部变量——除非告知Python将其声明为全局变量。<br>怎样告知Python这是一个全局变量呢？<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="prompt">&gt;&gt;&gt; </span>x = <span class="number">1</span></span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">change_global</span><span class="params">()</span>:</span></span><br><span class="line">        <span class="keyword">global</span> x</span><br><span class="line">        x = x + <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span>change_global()</span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span>x</span><br><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure></p>
<h4 id="闭包">闭包</h4><p>Python的函数可以嵌套，就是说一个函数可以放在另一个函数里面。比如：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">multiplier</span><span class="params">(factor)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">multiplyByFactor</span><span class="params">(number)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> number * factor</span><br><span class="line">    <span class="keyword">return</span> multiplyByFactor</span><br></pre></td></tr></table></figure></p>
<p>一个函数位于另一个里面，外层函数返回里层函数，也就是说函数本身被返回了（但是并没有被调用）。<br>重要的是返回的函数可以访问它定义所在的作用域，换句话说，它带着它的环境（和相关局部变量）。<br>每次调用外层函数，其内部函数都会重新绑定，factor的变量每次都有一个新值。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="prompt">&gt;&gt;&gt; </span>double = multiplier(<span class="number">2</span>)</span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span>double(<span class="number">5</span>)</span><br><span class="line"><span class="number">10</span></span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span>triple = multiplier(<span class="number">3</span>)</span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span>triple(<span class="number">3</span>)</span><br><span class="line"><span class="number">9</span></span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span>multiplier(<span class="number">5</span>)(<span class="number">4</span>)</span><br><span class="line"><span class="number">20</span></span><br></pre></td></tr></table></figure></p>
<p>这种存储子封闭作用域的行为叫做闭包。<br>举个例子：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="prompt">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">line_conf</span><span class="params">(a, b)</span>:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">line</span><span class="params">(x)</span>:</span></span><br><span class="line">            <span class="keyword">return</span> ax + b</span><br><span class="line">        <span class="keyword">return</span> line</span><br><span class="line"></span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span>line1 = line_conf(<span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span>line2 = line_conf(<span class="number">4</span>, <span class="number">5</span>)</span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span>print(line1(<span class="number">5</span>), line2(<span class="number">5</span>))</span><br></pre></td></tr></table></figure></p>
<p>这个例子中，函数line与环境变量a,b构成闭包。<br>在创建闭包的时候，我们通过line_conf的参数a,b说明了这两个环境变量的取值，这样，我们就确定了函数的最终形式(y = x + 1和y = 4x + 5)。<br>我们只需要变换参数a,b，就可以获得不同的直线表达函数。<br>由此，我们可以看到，闭包也具有提高代码可复用性的作用。<br>如果没有闭包，我们需要每次创建直线函数的时候同时说明a,b,x。<br>这样，我们就需要更多的参数传递，也减少了代码的可移植性。<br>利用闭包，我们实际上创建了<strong>泛函</strong>。<br>line函数定义一种广泛意义的函数。<br>这个函数的一些方面已经确定(必须是直线)，但另一些方面(比如a和b参数待定)。<br>随后，我们根据line_conf传递来的参数，通过闭包的形式，将最终函数确定下来。</p>
<h2 id="类和对象">类和对象</h2><h3 id="对象基本概念">对象基本概念</h3><p>Python是一门<strong>面向对象</strong>的语言。<br><strong>对象</strong>就是数据以及一系列存取、操作这些数据的方法的集合。<br>面向对象的特性主要是三个：</p>
<ul>
<li>多态：可以对不同类的对象使用同样的操作</li>
<li>封装：对外部世界隐藏对象的工作细节</li>
<li>继承：以普通的类为基础建立专门的类对象</li>
</ul>
<h3 id="类">类</h3><h4 id="创建类">创建类</h4><p>先来看一个简单的类：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">__metaclass__ = type <span class="comment"># 确定使用新式类</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>:</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">setName</span><span class="params">(self, name)</span>:</span></span><br><span class="line">		self.name = name</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">getName</span><span class="params">(self)</span>:</span></span><br><span class="line">		<span class="keyword">return</span> self.name</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">greet</span><span class="params">(self)</span>:</span></span><br><span class="line">		<span class="keyword">print</span> <span class="string">"Hello, I'm $s."</span> % self.name</span><br></pre></td></tr></table></figure></p>
<p>Person就是类名。<br>class语句会在函数定义的地方创建自己的命名空间。<br>self是对于对象自身的引用。<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; foo = Person()</span><br><span class="line">&gt;&gt;&gt; bar = Person()</span><br><span class="line">&gt;&gt;&gt; foo.setName('Luck Skywalker')</span><br><span class="line">&gt;&gt;&gt; bar.setName('Anakin Skywalker')</span><br><span class="line">&gt;&gt;&gt; foo.greet()</span><br><span class="line">Hello, I'm Luck Skywalker.</span><br><span class="line">&gt;&gt;&gt; bar.greet()</span><br><span class="line">Hello, I'm Anakin Skywalker.</span><br></pre></td></tr></table></figure></p>
<p>调用上面的函数时，对象自动将自己作为第一个参数传入函数中——因此形象的命名为self。<br>如果没有self，成员函数就没法访问需要进行操作的对象本身。<br>生成实例的时候，self会被当成实例本身传入，不论方法中有没有写self。<br><strong>所以如果类中的实例方法没有参数的话，就会报错。</strong><br>当然，属性也可以在外部访问：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="prompt">&gt;&gt;&gt; </span>foo.name</span><br><span class="line"><span class="string">'Luke Skywalker'</span></span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span>bar.name = <span class="string">'Yoda'</span></span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span>bar.gree()</span><br><span class="line">Hello, I<span class="string">'m Yoda.</span></span><br></pre></td></tr></table></figure></p>
<h4 id="属性和方法">属性和方法</h4><p>可以将普通函数绑定给类的方法：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="prompt">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">Class</span>:</span></span><br><span class="line">		<span class="function"><span class="keyword">def</span> <span class="title">method</span><span class="params">(self)</span>:</span></span><br><span class="line">			<span class="keyword">print</span> <span class="string">'I have a self'</span></span><br><span class="line"></span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">function</span><span class="params">()</span>:</span></span><br><span class="line">		<span class="keyword">print</span> <span class="string">"I don't..."</span></span><br><span class="line"></span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span>instance = Class()</span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span>instance.method()</span><br><span class="line">I have a self</span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span>instance.method = function</span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span>instance.method()</span><br><span class="line">I don<span class="string">'t...</span></span><br></pre></td></tr></table></figure></p>
<p>也可以将类的方法绑定到普通函数上：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="prompt">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">Bird</span>:</span></span><br><span class="line">		song = <span class="string">'BBB'</span></span><br><span class="line"></span><br><span class="line">		<span class="function"><span class="keyword">def</span> <span class="title">sing</span><span class="params">(self)</span>:</span></span><br><span class="line">			<span class="keyword">print</span> self.song</span><br><span class="line"></span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span>bird = Bird()</span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span>bird.sing()</span><br><span class="line">BBB</span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span>birdsong = bird.sing</span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span>birdsong()</span><br><span class="line">BBB</span><br></pre></td></tr></table></figure></p>
<h5 id="私有化">私有化</h5><p>Python并不直接支持私有方式，主要靠程序员自己把握在外部进行特性修改的时机。<br>但还是有一些小技巧达到私有化的效果。<br>要让方法或属性变为私有，可以在其名字前加上双下划线。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Secretive</span>:</span></span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__inaccessible</span><span class="params">(self)</span>:</span></span><br><span class="line">		<span class="keyword">print</span> <span class="string">'Bet you can not see...'</span></span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">accessible</span><span class="params">(self)</span>:</span></span><br><span class="line">		<span class="keyword">print</span> <span class="string">'The secret msg is:'</span></span><br><span class="line">		self.__inaccessible()</span><br><span class="line"></span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span>s = Secretive()</span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span>s.__inaccessible()</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">AttributeError: Secretive instance has no attribute <span class="string">'__inaccessible'</span></span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span></span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span>s.accessible()</span><br><span class="line">The secret msg <span class="keyword">is</span>:</span><br><span class="line">Bet you can <span class="keyword">not</span> see...</span><br></pre></td></tr></table></figure></p>
<p>实际上，所有双下划线开头的方法都被翻译为前面加上单下划线和类名的形式。<br>也就是说，实际还是可以在类外访问这些私有方法的。<br><strong>但不要这么做！</strong><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="prompt">&gt;&gt;&gt; </span>Secretive._Secretive__inaccessible</span><br><span class="line">&lt;unbound method Secretive.__inaccessible&gt;</span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span>s._Secretive__inaccessible()</span><br><span class="line">Bet you can <span class="keyword">not</span> see...</span><br></pre></td></tr></table></figure></p>
<p><strong>前面有下划线的名字都不会被带星号的imports语句（from module import*）导入</strong></p>
<h4 id="类的命名空间">类的命名空间</h4><p>所有位于class语句内的代码都在特殊的命名空间中执行——<strong>类命名空间</strong>。<br>类的命名空间可以由类内所有成员访问。<br>类的定义其实就是执行代码块，这一点非常有用，比如，在类的定义区中并不只限于使用def语句：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="prompt">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">C</span>:</span></span><br><span class="line">		<span class="keyword">print</span> <span class="string">'Class C being defined...'</span></span><br><span class="line"></span><br><span class="line">Class C being defined...</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure></p>
<p>再看下一段代码：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt;	<span class="class"><span class="keyword">class</span> <span class="title">MemberCount</span>:</span></span><br><span class="line"></span><br><span class="line">	    members = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	    <span class="function"><span class="keyword">def</span> <span class="title">init</span><span class="params">(self)</span>:</span></span><br><span class="line">	        MemberCount.members += <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span>m1 = MemberCount()</span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span>m1.init()</span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span>MemberCount.members</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span>m2 = MemberCount()</span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span>m2.init()</span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span>MemberCount.members</span><br><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure></p>
<p>上面的代码在类的作用域内定义了一个可供所有成员（实例）访问的变量，用来计算类的成员数量。<br>而类内作用域的变量也可以被所有实例访问：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="prompt">&gt;&gt;&gt; </span>m1.members</span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span>m2.members</span><br><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure></p>
<p>但如果重新绑定的话：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="prompt">&gt;&gt;&gt; </span>m1.members = <span class="string">'Two'</span></span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span>m1.members</span><br><span class="line"><span class="string">'Two'</span></span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span>m2.members</span><br><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure></p>
<h4 id="指定超类">指定超类</h4><p>将其他类名写在class语句后面的圆括号内就可以指定超类了。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Filter</span>:</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">init</span><span class="params">(self)</span>:</span></span><br><span class="line">		self.blocked = []</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">filter</span><span class="params">(self, sequence)</span>:</span></span><br><span class="line">		<span class="keyword">return</span> [x <span class="keyword">for</span> x <span class="keyword">in</span> sequence <span class="keyword">if</span> x <span class="keyword">not</span> <span class="keyword">in</span> self.blocked] <span class="comment"># 第一次见这种代码</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SPAMFilter</span><span class="params">(Filter)</span>:</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">init</span><span class="params">(self)</span>:</span></span><br><span class="line">		self.blocked = [<span class="string">'SPAM'</span>]</span><br></pre></td></tr></table></figure></p>
<p>Filter是过滤基类，事实上，它不能过滤任何东西。<br>SPAMFilter是子类，可以将序列中的“SPAM”过滤掉。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="prompt">&gt;&gt;&gt; </span>s = SPAMFilter()</span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span>s.init()</span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span>s.filter([<span class="string">'SPAM'</span>, <span class="string">'egg'</span>, <span class="string">'SPAM'</span>, <span class="string">'SPAM'</span>, <span class="string">'bacon'</span>])</span><br><span class="line">[<span class="string">'egg'</span>, <span class="string">'bacon'</span>]</span><br></pre></td></tr></table></figure></p>
<h4 id="查看继承关系">查看继承关系</h4><p>查看继承关系用内建的<em>issubclass</em>函数：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="prompt">&gt;&gt;&gt; </span>issubclass(SPAMFilter, Filter)</span><br><span class="line"><span class="keyword">True</span></span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span>issubclass(Filter, issubclass)</span><br><span class="line"><span class="keyword">False</span></span><br></pre></td></tr></table></figure></p>
<p>也可以用内建的<em>isinstance</em>函数检查一个对象是否是一个类的实例：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="prompt">&gt;&gt;&gt; </span>s = SPAMFilter()</span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span>isinstance(s, SPAMFilter)</span><br><span class="line"><span class="keyword">True</span></span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span>isinstance(s, Filter)</span><br><span class="line"><span class="keyword">True</span></span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span>isinstance(s, str)</span><br><span class="line"><span class="keyword">False</span></span><br></pre></td></tr></table></figure></p>
<p>想知道一个类的基类，使用其特殊属性__bases__<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; SPAMFilter.__bases__</span><br><span class="line">(&lt;class __main__.Filter at 0x10b8107a0&gt;,)</span><br></pre></td></tr></table></figure></p>
<p>想知道一个实例属于哪个类，可以用__class__属性<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="prompt">&gt;&gt;&gt; </span>s.__class__</span><br><span class="line">&lt;<span class="class"><span class="keyword">class</span> <span class="title">__main__</span>.<span class="title">SPAMFilter</span> <span class="title">at</span> 0<span class="title">x10b810808</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<h4 id="多重继承">多重继承</h4><p>上面提到了__bases__，是复数形式，意味着基类可以是多个。<br>事实上的确如此：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Calculator</span>:</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">calculate</span><span class="params">(self, expression)</span>:</span></span><br><span class="line">		self.value = eval(expression)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Talker</span>:</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">talk</span><span class="params">(self)</span>:</span></span><br><span class="line">		<span class="keyword">print</span> <span class="string">'Hi, my value is'</span>, self.value</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TalkingCalculator</span><span class="params">(Calculator, Talker)</span>:</span></span><br><span class="line">	<span class="keyword">pass</span></span><br></pre></td></tr></table></figure></p>
<p>子类自己不做任何事情，从自己的超类中继承所有行为。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="prompt">&gt;&gt;&gt; </span>tc = TalkingCalculator()</span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span>tc.calculate(<span class="string">'1 + 2 * 3'</span>)</span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span>tc.talk()</span><br><span class="line">Hi, my value <span class="keyword">is</span> <span class="number">7</span></span><br></pre></td></tr></table></figure></p>
<p>多重继承有个问题需要注意，如果一个方法从多个超类继承，那么必须注意一下超类的顺序。<br><strong>先继承的类中的方法会重写后继承的类中的方法</strong>。<br>如果上面的Calculator也有一个talk方法，就会重写Talker的talk方法。</p>
<h3 id="一些面向对象的思考">一些面向对象的思考</h3><ul>
<li>将属于一类的对象放在一起。如果一个函数操纵一个全局变量，那么两者最好都在类内作为特性和方法出现。</li>
<li>对象应该只关心自己实例的特性，让其他实例管理自己的状态。</li>
<li>小心继承，特别是多重继承。</li>
</ul>
<h2 id="异常">异常</h2><h3 id="什么是异常">什么是异常</h3><p>Python用<strong>异常对象</strong>来表示异常情况。<br>遇到错误，就会引发异常。<br>如果异常没有被处理或捕获。程序就会用回溯（Traceback）终止执行：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="prompt">&gt;&gt;&gt; </span><span class="number">1</span>/<span class="number">0</span></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">ZeroDivisionError: integer division <span class="keyword">or</span> modulo by zero</span><br></pre></td></tr></table></figure></p>
<p>事实上，每一个异常都是一些类的实例，比如上面的就是ZeroDivisionError。<br>这些实例可以被引发，并且可以用多种方法进行捕捉，使程序可以捉住作物并对其进行处理，而不是让整个程序失效。</p>
<h3 id="自己的异常">自己的异常</h3><h4 id="raise语句">raise语句</h4><p>可以使用一个类（Exception的子类）或者实例参数调用raise语句，来引发异常。<br>使用类的时候，程序自动创建实例。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="prompt">&gt;&gt;&gt; </span><span class="keyword">raise</span> Exception</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">Exception</span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span><span class="keyword">raise</span> Exception(<span class="string">'overload'</span>)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">Exception: overload</span><br></pre></td></tr></table></figure></p>
<p>内建的异常类有很多，这些类都可以在exceptions模块中找到。<br>常见的异常类有：</p>
<table>
<thead>
<tr>
<th>class name</th>
<th>description </th>
</tr>
</thead>
<tbody>
<tr>
<td>Exception</td>
<td>所有异常的基类</td>
</tr>
<tr>
<td>AttributeError</td>
<td>特性引用或赋值失败</td>
</tr>
<tr>
<td>IOError</td>
<td>试图打开不存在的文件（也有其他情况）</td>
</tr>
<tr>
<td>IndexError</td>
<td>使用序列中不存在的索引</td>
</tr>
<tr>
<td>KeyError</td>
<td>使用映射中不存在的键</td>
</tr>
<tr>
<td>NameError</td>
<td>找不到名字（变量）</td>
</tr>
<tr>
<td>SyntaxError</td>
<td>代码为错误形式时引发</td>
</tr>
<tr>
<td>TypeError</td>
<td>内建操作或者函数应用于错误类型的对象</td>
</tr>
<tr>
<td>ValueError</td>
<td>内建操作或者函数应用于正确类型的对象，但是该对象使用不合适的值</td>
</tr>
</tbody>
</table>
<h4 id="自定义异常类">自定义异常类</h4><p>创建自己的异常类，只需要继承Exception即可。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SomeCustomException</span><span class="params">(Exception)</span>:</span> <span class="keyword">pass</span></span><br></pre></td></tr></table></figure></p>
<h3 id="捕捉异常">捕捉异常</h3><p>处理异常可以用<em>try/catch</em>来实现。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">	x = input(<span class="string">'Enter first num:'</span>)</span><br><span class="line">	y = input(<span class="string">'Enter second num:'</span>)</span><br><span class="line">	<span class="keyword">print</span> x/y</span><br><span class="line"><span class="keyword">except</span> ZeroDivisionError:</span><br><span class="line">	<span class="keyword">print</span> <span class="string">"The second num can't be zero!"</span></span><br></pre></td></tr></table></figure></p>
<p>如果捕获了异常，却又想重新引发它，就可以用不带参数的raise。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MuffledCalculator</span>:</span></span><br><span class="line">	muffled = false</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">calc</span><span class="params">(self, expr)</span>:</span></span><br><span class="line">		<span class="keyword">try</span>:</span><br><span class="line">			<span class="keyword">return</span> eval(expr)</span><br><span class="line">		<span class="keyword">except</span> ZeroDivisionError:</span><br><span class="line">			<span class="keyword">if</span> self.muffled:</span><br><span class="line">				<span class="keyword">print</span> <span class="string">'Division by zero is illegal'</span></span><br><span class="line">			<span class="keyword">else</span>:</span><br><span class="line">				<span class="keyword">raise</span></span><br></pre></td></tr></table></figure></p>
<h3 id="多个Except">多个Except</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">	x = input(<span class="string">'Enter the first num'</span>)</span><br><span class="line">	y = input(<span class="string">'Enter the second num'</span>)</span><br><span class="line">	<span class="keyword">print</span> x/y</span><br><span class="line"><span class="keyword">except</span> ZeroDivisionError:</span><br><span class="line">	<span class="keyword">print</span> <span class="string">'ZeroDivisionError'</span></span><br><span class="line"><span class="keyword">except</span> TypeError:</span><br><span class="line">	<span class="keyword">print</span> <span class="string">'TypeError'</span></span><br></pre></td></tr></table></figure>
<p>这样的代码比用多个if/else可读性高的多</p>
<h3 id="一个块捕获多个异常">一个块捕获多个异常</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">	x = input(<span class="string">'Enter the first num'</span>)</span><br><span class="line">	y = input(<span class="string">'Enter the second num'</span>)</span><br><span class="line">	<span class="keyword">print</span> x/y</span><br><span class="line"><span class="keyword">except</span> (ZeroDivisionError, TypeError, NameError):</span><br><span class="line">	<span class="keyword">print</span> <span class="string">'Your num were bugs...'</span></span><br></pre></td></tr></table></figure>
<h3 id="获取异常对象">获取异常对象</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">	x = input(<span class="string">'Enter the first num'</span>)</span><br><span class="line">	y = input(<span class="string">'Enter the second num'</span>)</span><br><span class="line">	<span class="keyword">print</span> x/y</span><br><span class="line"><span class="keyword">except</span> (ZeroDivisionError, TypeError), e:</span><br><span class="line">	<span class="keyword">print</span> e</span><br></pre></td></tr></table></figure>
<h3 id="全捕获异常">全捕获异常</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">	x = input(<span class="string">'Enter the first num'</span>)</span><br><span class="line">	y = input(<span class="string">'Enter the second num'</span>)</span><br><span class="line">	<span class="keyword">print</span> x/y</span><br><span class="line"><span class="keyword">except</span>:</span><br><span class="line">	<span class="keyword">print</span> <span class="string">'Something wrong happened...'</span></span><br></pre></td></tr></table></figure>
<h3 id="异常中的else">异常中的else</h3><p>可以像对条件和循环语句那样，给try/catch语句加上一个else子句。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">	<span class="keyword">try</span>:</span><br><span class="line">		x = input(<span class="string">'Enter the first num'</span>)</span><br><span class="line">		y = input(<span class="string">'Enter the second num'</span>)</span><br><span class="line">		<span class="keyword">print</span> x/y</span><br><span class="line">	<span class="keyword">except</span>:</span><br><span class="line">		<span class="keyword">print</span> <span class="string">'Something wrong happened...'</span></span><br><span class="line">	<span class="keyword">else</span>:</span><br><span class="line">		<span class="keyword">break</span></span><br></pre></td></tr></table></figure></p>
<p>这个循环只有在没有异常发生的情况下才退出，换句话说，如果有错误，就会不断要求重新输入。</p>
<h3 id="Finally">Finally</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">	<span class="number">1</span> / <span class="number">0</span></span><br><span class="line"><span class="keyword">except</span>:</span><br><span class="line">	<span class="keyword">print</span> <span class="string">"Error"</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">	<span class="keyword">print</span> <span class="string">"That were well"</span></span><br><span class="line"><span class="keyword">finally</span>:</span><br><span class="line">	<span class="keyword">print</span> <span class="string">"Cleaning up"</span></span><br></pre></td></tr></table></figure>
<p>Finally语句可以用来异常后的清理，常用于关闭文件或者网络套接字。</p>
<h2 id="异常和函数">异常和函数</h2><p>如果函数中的异常没有得到处理，就会一层一层往上抛，直到主程序，如果那里也没有处理异常的逻辑，程序就会带着堆栈跟踪信息终止。</p>
<h2 id="深入方法和类">深入方法和类</h2><h3 id="构造方法">构造方法</h3><p>一个对象被创建后，会立即调用构造方法。<br>在Python中创建一个构造方法就是写一个__init__方法：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FooBar</span>:</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">		self.somevar = <span class="number">42</span></span><br><span class="line"></span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span>f = FooBar()</span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span>f.somevar</span><br><span class="line"><span class="number">42</span></span><br></pre></td></tr></table></figure></p>
<p>在构造方法中加入参数的情况：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FooBar</span>:</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, value = <span class="number">42</span>)</span>:</span></span><br><span class="line">		self.somevar = value</span><br><span class="line"></span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span>f = FooBar()</span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span>f.somevar</span><br><span class="line"><span class="number">42</span></span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span>f = FooBar(<span class="string">'Hello'</span>)</span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span>f.somevar</span><br><span class="line"><span class="string">'Hello'</span></span><br></pre></td></tr></table></figure></p>
<p>Python里面还有<strong>析构函数</strong>——<em>__del__</em>。<br>它在对象要被垃圾回收之前调用，但是发生调用的具体时机不可知，所以要<strong>尽量避免使用</strong>。</p>
<h4 id="重写构造方法">重写构造方法</h4><p>重写是继承机制里面一个重要内容，对于构造方法尤其重要。<br>构造方法用来初始化新建对象的状态，大多数子类不仅要拥有自己的初始化代码，还要拥有超类的初始化代码。<br>考虑下面这个Bird类：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bird</span>:</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">		self.hungry = <span class="keyword">True</span></span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">eat</span><span class="params">(self)</span>:</span></span><br><span class="line">		<span class="keyword">if</span> self.hungry:</span><br><span class="line">			<span class="keyword">print</span> <span class="string">'Ahaaa...'</span></span><br><span class="line">			self.hungry = <span class="keyword">False</span></span><br><span class="line">		<span class="keyword">else</span>:</span><br><span class="line">			<span class="keyword">print</span> <span class="string">'No, thanks!'</span></span><br></pre></td></tr></table></figure></p>
<p>考虑其一个子类SomeBird：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SomeBird</span><span class="params">(Bird)</span>:</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">		self.sound = <span class="string">'Squawk'</span></span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">sing</span><span class="params">(self)</span>:</span></span><br><span class="line">		pting self.sound</span><br></pre></td></tr></table></figure></p>
<p>调用这个子类的<em>sing()</em>方法会正常唱歌，但是，如果调用<em>eat()</em>方法，就会抛出异常。<br>异常显示SomeBird没有hungry属性，这是因为SomeBird重写了构造方法，新的构造方法里面没有任何关于初始化hungry的代码。<br>要实现预期效果，SomeBird的构造方法必须调用其超类的构造方法来确保进行基本的初始化。<br>实现这个有两种方法：</p>
<ul>
<li>调用超类构造方法的未绑定版本</li>
<li>使用super函数</li>
</ul>
<h5 id="未绑定方法">未绑定方法</h5><p>这个方法是历史方法，现在一般不推荐使用：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SomeBird</span><span class="params">(Bird)</span>:</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">		Bird.__init__(self)</span><br><span class="line">		self.sound = <span class="string">'Squawk'</span></span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">sing</span><span class="params">(self)</span>:</span></span><br><span class="line">		pting self.sound</span><br></pre></td></tr></table></figure></p>
<p>可以发现，添加了一行代码：<em>Bird.<strong>init</strong>(self)</em>。<br><strong>在调用一个实例的方法时，这个方法的self参数会自动绑定到实例上。但是如果直接调用类的方法，就没有实例会被绑定，这样就可以自由的提供需要的self参数。这种称为未绑定方法。</strong><br>通过将当前实例作为self参数提供给未绑定方法，SomeBird就能使用其超类构造方法的所有实现。</p>
<h5 id="super函数">super函数</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">__metaclass__ = type <span class="comment"># super函数只能在新式类中起作用</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bird</span>:</span></span><br><span class="line">......</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SomeBird</span><span class="params">(Bird)</span>:</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">		super(SomeBird, self).__init__()</span><br><span class="line">		self.sound = <span class="string">'Squawk'</span></span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">sing</span><span class="params">(self)</span>:</span></span><br><span class="line">		pting self.sound</span><br></pre></td></tr></table></figure>
<h3 id="成员访问">成员访问</h3>
  </section>

  
  
</article>


            <footer class="footer">

    <span class="footer__copyright">&copy; 2014-2015. | 由<a href="https://hexo.io/">Hexo</a>强力驱动 | 主题<a href="https://github.com/someus/huno">Huno</a></span>
    
</footer>
        </div>
    </div>

    <!-- js files -->
    <script src="/js/jquery.min.js"></script>
    <script src="/js/main.js"></script>
    <script src="/js/scale.fix.js"></script>
    

    

    <script type="text/javascript" src="//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <script type="text/javascript"> 
        $(document).ready(function(){
            MathJax.Hub.Config({ 
                tex2jax: {inlineMath: [['[latex]','[/latex]'], ['\\(','\\)']]} 
            });
        });
    </script>


    

    <script src="/js/awesome-toc.min.js"></script>
    <script>
        $(document).ready(function(){
            $.awesome_toc({
                overlay: true,
                contentId: "post-content",
            });
        });
    </script>


    
    
    <!--kill ie6 -->
<!--[if IE 6]>
  <script src="//letskillie6.googlecode.com/svn/trunk/2/zh_CN.js"></script>
<![endif]-->

</body>
</html>
