<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Android中的View浅析 | DoubleChen，就这样</title>
  <meta name="viewport" content="width=device-width">
  <meta name="description" content="简介View，耳熟能详，无人不识，但是否无人不知呢？这里先来看看官方文档对View的定义。

This class represents the basic building block for user interface components. A View occupies a rectangular area on the screen and is responsible for dra">
<meta property="og:type" content="article">
<meta property="og:title" content="Android中的View浅析">
<meta property="og:url" content="http://yoursite.com/2015/11/02/view/index.html">
<meta property="og:site_name" content="DoubleChen，就这样">
<meta property="og:description" content="简介View，耳熟能详，无人不识，但是否无人不知呢？这里先来看看官方文档对View的定义。

This class represents the basic building block for user interface components. A View occupies a rectangular area on the screen and is responsible for dra">
<meta property="og:updated_time" content="2015-11-03T09:08:10.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Android中的View浅析">
<meta name="twitter:description" content="简介View，耳熟能详，无人不识，但是否无人不知呢？这里先来看看官方文档对View的定义。

This class represents the basic building block for user interface components. A View occupies a rectangular area on the screen and is responsible for dra">
  
    <link rel="alternative" href="/atom.xml" title="DoubleChen，就这样" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  <link rel="stylesheet" href="/css/style.css" type="text/css">
  <!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->
  
</head>
<body>
  <div id="container">
    <div class="mobile-nav-panel">
	<i class="icon-reorder icon-large"></i>
</div>
<header id="header">
	<h1 class="blog-title">
		<a href="/">DoubleChen，就这样</a>
	</h1>
	<nav class="nav">
		<ul>
			<li><a href="/">Home</a></li><li><a href="/archives">Archives</a></li>
			<li><a id="nav-search-btn" class="nav-icon" title="Search"></a></li>
			<li><a href="/atom.xml" id="nav-rss-link" class="nav-icon" title="RSS Feed"></a></li>
		</ul>
	</nav>
	<div id="search-form-wrap">
		<form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" results="0" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
	</div>
</header>
    <div id="main">
      <article id="post-view" class="post">
	<footer class="entry-meta-header">
		<span class="meta-elements date">
			<a href="/2015/11/02/view/" class="article-date">
  <time datetime="2015-11-01T16:00:00.000Z" itemprop="datePublished">2015-11-02</time>
</a>
		</span>
		<span class="meta-elements author">Double Chen</span>
		<div class="commentscount">
			
		</div>
	</footer>
	
	<header class="entry-header">
		
  
    <h1 class="article-title entry-title" itemprop="name">
      Android中的View浅析
    </h1>
  

	</header>
	<div class="entry-content">
		
    	<h2 id="简介">简介</h2><p>View，耳熟能详，无人不识，但是否无人不知呢？这里先来看看官方文档对View的定义。</p>
<blockquote>
<p>This class represents the basic building block for user interface components. A View occupies a rectangular area on the screen and is responsible for drawing and event handling. View is the base class for widgets, which are used to create interactive UI components (buttons, text fields, etc.). The ViewGroup subclass is the base class for layouts, which are invisible containers that hold other Views (or other ViewGroups) and define their layout properties.</p>
</blockquote>
<p>简单来说，<strong>View</strong>是用户交互的基础组成部分，占据了屏幕中的一个矩形区域，主要工作涉及绘制以及事件响应。 View是所有控件的基础，用来创建UI交互（按钮，文字区域等）。View的直接子类<strong>ViewGroup</strong>是布局基础，用来包含其他View或者其他ViewGroup并定义其布局属性。</p>
<a id="more"></a>
<h2 id="View的属性">View的属性</h2><h4 id="IDs">IDs</h4><p>每个View都对应了一个ID，这个很基础。不过需要注意的是，官方文档指出，<strong>View的ID在整个View树里面不需要唯一</strong>，甚至在一个布局文件里面都可以有两个同ID的View。但是，平时开发中，要保证你当前操作的父View下的子View都有唯一的ID，否则虽然编译不会报错，但是同ID的View只有一个会生效，其他的会失效。这是因为findViewById(int)会去遍历View树并返回匹配的第一个View。<br>除了在XML中定义View的ID，还可以通过代码动态的设置ID，调用View的setId(int)方法即可。<br>在API 17之后，可以通过View.generateViewId()去生成一个动态的唯一的ID，在这之前，可以在<strong>values/ids.xml</strong>文件中定义一个ID。<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span><br><span class="line">&lt;resources&gt;</span><br><span class="line">    &lt;item name="reservedNamedId" type="id"/&gt;</span><br><span class="line">&lt;/resources&gt;</span><br></pre></td></tr></table></figure></p>
<p>然后在动态创建了View或者ViewGroup之后将这个ID赋给它。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">myViewGroup.setId(R.id.reservedNamedId);</span><br></pre></td></tr></table></figure></p>
<h4 id="Position">Position</h4><p>View是矩形的，通过左上角的坐标和宽高四个数值来唯一定义其位置，这些数值的单位是<strong>像素</strong>。通过调用getLeft()和getTop()可以得到一个View的位置，但要特别注意的是，这两个方法返回的是<strong>相对于其父元素的位置</strong>。</p>
<h4 id="Size,_padding_and_margins">Size, padding and margins</h4><p>measured width和measured height定义了一个View想在其父View中占据多大的空间。这两个值可以通过getMeasuredWidth()和getMeasuredHeight()方法获得。<br>width和height是View在绘制之后的实际宽高，跟measured width和measured height不一定相同。可以通过getWidth()和getHeight()方法获得。<br>计算View的尺寸时，还要将padding考虑进去。相关方法是setPadding(int, int, int, int)或者setPaddingRelative(int, int, int, int)，还有getPaddingLeft(), getPaddingTop(), getPaddingRight(), getPaddingBottom(), getPaddingStart(), getPaddingEnd()等。<br>View不支持margins，但是ViewGroup提供支持。</p>
<h4 id="Tag">Tag</h4><p>tag常常用来存储跟View相关的数据。</p>
<h2 id="自定义属性">自定义属性</h2><p>在<strong>res/values</strong>文件下定义一个<strong>attrs.xml</strong>文件：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version="1.0" encoding="utf-8"?&gt;  </span><br><span class="line">&lt;resources&gt;  </span><br><span class="line">    &lt;declare-styleable name="MyView"&gt;  </span><br><span class="line">        &lt;attr name="textColor" format="color" /&gt;  </span><br><span class="line">        &lt;attr name="textSize" format="dimension" /&gt;  </span><br><span class="line">    &lt;/declare-styleable&gt;  </span><br><span class="line">&lt;/resources&gt;</span><br></pre></td></tr></table></figure></p>
<p>然后在自定义View的构造方法中获取我们定义的属性值。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">MyView</span><span class="params">(Context context,AttributeSet attrs)</span> </span>&#123; </span><br><span class="line">	<span class="keyword">super</span>(context,attrs);  </span><br><span class="line">	mPaint = <span class="keyword">new</span> Paint();  </span><br><span class="line">	  </span><br><span class="line">	TypedArray a = context.obtainStyledAttributes(attrs,  </span><br><span class="line">			R.styleable.MyView);  </span><br><span class="line">	  </span><br><span class="line">	<span class="keyword">int</span> textColor = a.getColor(R.styleable.MyView_textColor,  </span><br><span class="line">			<span class="number">0XFFFFFFFF</span>);  </span><br><span class="line">	<span class="keyword">float</span> textSize = a.getDimension(R.styleable.MyView_textSize, <span class="number">36</span>);  </span><br><span class="line">	  </span><br><span class="line">	mPaint.setTextSize(textSize);  </span><br><span class="line">	mPaint.setColor(textColor);  </span><br><span class="line">	  </span><br><span class="line">	a.recycle();  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>将自定义View加到布局中，并使用我们的自定义属性：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml   </span><br><span class="line">version="1.0" encoding="utf-8"?&gt;  </span><br><span class="line">&lt;LinearLayout   </span><br><span class="line">	xmlns:android="http://schemas.android.com/apk/res/android"</span><br><span class="line">	xmlns:test="http://schemas.android.com/apk/res/com.android.tutor"  </span><br><span class="line">    android:orientation="vertical"  </span><br><span class="line">    android:layout_width="fill_parent"  </span><br><span class="line">    android:layout_height="fill_parent" &gt; </span><br><span class="line">	&lt;com.android.tutor.MyView  </span><br><span class="line">		android:layout_width="fill_parent"   </span><br><span class="line">		android:layout_height="fill_parent"   </span><br><span class="line">		test:textSize="20px"  </span><br><span class="line">		test:textColor="#fff" /&gt;  </span><br><span class="line">&lt;/LinearLayout&gt;</span><br></pre></td></tr></table></figure></p>
<p>这边要特别注意这一行：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xmlns:test=<span class="string">"http://schemas.android.com/apk/res/com.android.tutor"</span></span><br></pre></td></tr></table></figure></p>
<p>这边xmlns后边的test这个名字可以任意取，属性设置就是使用这个名字开头。而<strong>com.android.tutor</strong>就是我们的包名。<br>但是，<strong>当想要引用的自定义控件为library时，并且此控件也具有自定义的属性，就是说它在attrs.xml中有自定义属性，此时在新项目中引用时，就不能在xml中引用包名，而是引用</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xmlns:test=<span class="string">"http://schemas.android.com/apk/res-auto"</span></span><br></pre></td></tr></table></figure></p>
<h2 id="View的绘制过程">View的绘制过程</h2><p>View的绘制主要分以下三个过程：</p>
<h4 id="Measure">Measure</h4><p>View首先会计算一下自己的父View中占据多大的空间，测量过程（measuring pass）是在measure(int, int)中实现的，是从树的顶端由上到下进行的。在这个递归过程中，每一个View会把自己的dimension specifications传递下去。在measure pass的最后，每一个View都存储好了自己的measurements，即测量结果。<br>这个过程暴露给我们一个方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onMeasure</span><span class="params">(<span class="keyword">int</span> widthMeasureSpec, <span class="keyword">int</span> heightMeasureSpec)</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure></p>
<p>onMeasure()方法是测量view和它的内容，决定measured width和measured height的，这个方法由 measure(int, int)方法唤起，子类可以覆写onMeasure来提供更加准确和有效的测量。<br>有一个约定：在覆写onMeasure方法的时候，必须调用 setMeasuredDimension(int,int)来存储这个View经过测量得到的measured width and height。如果没有这么做，将会由measure(int, int)方法抛出一个<strong>IllegalStateException</strong>。<br>View类基本的onMeasure实现如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onMeasure</span><span class="params">(<span class="keyword">int</span> widthMeasureSpec, <span class="keyword">int</span> heightMeasureSpec)</span> </span>&#123;</span><br><span class="line">  setMeasuredDimension(getDefaultSize(getSuggestedMinimumWidth(), widthMeasureSpec),</span><br><span class="line">          getDefaultSize(getSuggestedMinimumHeight(), heightMeasureSpec));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getDefaultSize</span><span class="params">(<span class="keyword">int</span> size, <span class="keyword">int</span> measureSpec)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> result = size;</span><br><span class="line">  <span class="keyword">int</span> specMode = MeasureSpec.getMode(measureSpec);</span><br><span class="line">  <span class="keyword">int</span> specSize = MeasureSpec.getSize(measureSpec);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">switch</span> (specMode) &#123;</span><br><span class="line">  <span class="keyword">case</span> MeasureSpec.UNSPECIFIED:</span><br><span class="line">      result = size;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> MeasureSpec.AT_MOST:</span><br><span class="line">  <span class="keyword">case</span> MeasureSpec.EXACTLY:</span><br><span class="line">      result = specSize;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>其中invoke了setMeasuredDimension()方法，设置了measure过程中View的宽高，getSuggestedMinimumWidth()返回View的最小Width，Height也有对应的方法。<br>MeasureSpec类是View类的一个内部静态类，它定义了三个常量UNSPECIFIED、AT_MOST、EXACTLY，其实我们可以这样理解它，它们分别对应LayoutParams中match_parent、wrap_content、xxxdp。<br>如果我们不自己重写onMeasure，而用基础的onMeasure方法的话：</p>
<ul>
<li>CustomView设置为match_parent或者wrap_content没有任何区别，其显示大小由父控件决定，它会填充满整个父控件的空间</li>
<li>CustomView设置为固定的值，则其显示大小为该设定的值    </li>
</ul>
<p>我们可以重写onMeasure来重新定义View的宽高。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyView</span> <span class="keyword">extends</span> <span class="title">View</span> </span>&#123;  </span><br><span class="line">  </span><br><span class="line">    ......  </span><br><span class="line">      </span><br><span class="line">    <span class="annotation">@Override</span>  </span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onMeasure</span><span class="params">(<span class="keyword">int</span> widthMeasureSpec, <span class="keyword">int</span> heightMeasureSpec)</span> </span>&#123;  </span><br><span class="line">        setMeasuredDimension(<span class="number">200</span>, <span class="number">200</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这样的话就把View默认的测量流程覆盖掉了，不管在布局文件中定义MyView这个视图的大小是多少，<strong>最终在界面上显示的大小都将会是200*200</strong>。<br>再介绍一种比较复杂重写onMeasure的方式：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomView</span> <span class="keyword">extends</span> <span class="title">View</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_VIEW_WIDTH = <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_VIEW_HEIGHT = <span class="number">100</span>;</span><br><span class="line">	</span><br><span class="line">	...</span><br><span class="line">     </span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onMeasure</span><span class="params">(<span class="keyword">int</span> widthMeasureSpec, <span class="keyword">int</span> heightMeasureSpec)</span> </span>&#123;</span><br><span class="line">         </span><br><span class="line">        <span class="keyword">int</span> width  = measureDimension(DEFAULT_VIEW_WIDTH, widthMeasureSpec);</span><br><span class="line">        <span class="keyword">int</span> height = measureDimension(DEFAULT_VIEW_HEIGHT, heightMeasureSpec);</span><br><span class="line">         </span><br><span class="line">        setMeasuredDimension(width, height);                </span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">measureDimension</span><span class="params">( <span class="keyword">int</span> defaultSize, <span class="keyword">int</span> measureSpec )</span> </span>&#123;</span><br><span class="line">         </span><br><span class="line">        <span class="keyword">int</span> result = defaultSize;</span><br><span class="line">         </span><br><span class="line">        <span class="keyword">int</span> specMode = MeasureSpec.getMode(measureSpec);</span><br><span class="line">        <span class="keyword">int</span> specSize = MeasureSpec.getSize(measureSpec);</span><br><span class="line">                 </span><br><span class="line">        <span class="comment">//1. layout给出了确定的值，比如：100dp</span></span><br><span class="line">        <span class="comment">//2. layout使用的是match_parent，但父控件的size已经可以确定了，比如设置的是具体的值或者match_parent</span></span><br><span class="line">        <span class="keyword">if</span> (specMode == MeasureSpec.EXACTLY) &#123;      </span><br><span class="line">            result = specSize; <span class="comment">//建议：result直接使用确定值</span></span><br><span class="line">        &#125; </span><br><span class="line">        <span class="comment">//1. layout使用的是wrap_content</span></span><br><span class="line">        <span class="comment">//2. layout使用的是match_parent,但父控件使用的是确定的值或者wrap_content</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (specMode == MeasureSpec.AT_MOST) &#123;             </span><br><span class="line">            result = Math.min(defaultSize, specSize); <span class="comment">//建议：result不能大于specSize</span></span><br><span class="line">        &#125; </span><br><span class="line">        <span class="comment">//UNSPECIFIED,没有任何限制，所以可以设置任何大小</span></span><br><span class="line">        <span class="comment">//多半出现在自定义的父控件的情况下，期望由自控件自行决定大小</span></span><br><span class="line">        <span class="keyword">else</span> &#123;      </span><br><span class="line">            result = defaultSize; </span><br><span class="line">        &#125;</span><br><span class="line">         </span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>这样重载了onMeasure函数之后，你会发现，当CustomView使用match_parent的时候，它会占满整个父控件，而当CustomView使用wrap_content的时候，它的大小则是代码中定义的默认大小100x100像素。</strong><br>需要注意的是，在setMeasuredDimension()方法调用之后，我们才能使用getMeasuredWidth()和getMeasuredHeight()来获取视图测量出的宽高，以此之前调用这两个方法得到的值都会是0。<br>由此可见，视图大小的控制是由父视图、布局文件、以及视图本身共同完成的，父视图会提供给子视图参考的大小，而开发人员可以在XML文件中指定视图的大小，然后视图本身会对最终的大小进行拍板。</p>
<h4 id="Layout">Layout</h4><p>布局过程（layout pass），它发生在 layout(int, int, int, int)中，仍然是从上到下进行（top-down）。在这一遍中，每一个parent都会负责用测量过程中得到的尺寸，把自己的所有孩子放在正确的地方。<br>View给我们暴露了onLayout方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onLayout</span><span class="params">(<span class="keyword">boolean</span> changed, <span class="keyword">int</span> left, <span class="keyword">int</span> top, <span class="keyword">int</span> right, <span class="keyword">int</span> bottom)</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如果View没有子类，这一步我们就不需要做额外的工作，但如果是ViewGroup，就需要在onLayout方法中将所有子View的大小宽高设置好。<br>ViewGroup类的onLayout()函数是abstract型，继承者必须实现，由于ViewGroup的定位就是一个容器，用来盛放子控件的，所以就必须定义要以什么的方式来盛放，比如LinearLayout就是以横向或者纵向顺序存放，而RelativeLayout则以相对位置来摆放子控件，同样，我们的自定义ViewGroup也必须给出我们期望的布局方式，而这个定义就通过onLayout()函数来实现。<br>在onLayout()过程结束后，我们就可以调用getWidth()方法和getHeight()方法来获取视图的宽高了。<br>这里就涉及到一个问题，getWidth()方法和getMeasureWidth()方法到底有什么区别呢？    </p>
<ul>
<li>getMeasureWidth()方法在measure()过程结束后就可以获取到了，而getWidth()方法要在layout()过程结束后才能获取到</li>
<li>getMeasureWidth()方法中的值是通过setMeasuredDimension()方法来进行设置的，而getWidth()方法中的值则是通过视图右边的坐标减去左边的坐标计算出来的</li>
</ul>
<h4 id="Draw">Draw</h4><p>作为一个View，最重要的就是Draw的过程了，我们需要在Canvas上绘制出我们的View。<br>View调用draw()开始绘制，draw()方法实现的功能如下：</p>
<ol>
<li>绘制该View的背景</li>
<li>如果有必要的话，为显示渐变框做一些准备操作（大多数情况下，不需要改渐变框），比如保存Canvas的层</li>
<li>调用onDraw()方法绘制视图本身（每个View都需要重载该方法，ViewGroup不需要实现该方法）</li>
<li>调用dispatchDraw()方法绘制子视图（如果该View类型不为ViewGroup，即不包含子视图，不需要重载该方法）。dispatchDraw()方法内部会遍历每个子视图，调用drawChild()去重新回调每个子视图的draw()方法（注意，这个地方“需要重绘”的视图才会调用draw()方法）。值得说明的是，ViewGroup类已经为我们重写了dispatchDraw ()的功能实现，应用程序一般不需要重写该方法，但可以重载父类函数实现具体的功能。</li>
<li>有必要的话，绘制View四周的阴影渐变效果</li>
<li>绘制滚动条</li>
</ol>
<p>其中第三步，我们可以看到，View需要我们自己处理绘制步骤。<br>View暴露出的绘制方法是：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onDraw</span><span class="params">(Canvas canvas)</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>默认View类的onDraw方法没有一行代码，给我们提供了一块空白的画布，任我们自由的绘画。绘制主要借助了Canvas类。</p>
<h2 id="绘制的其他重要方法">绘制的其他重要方法</h2><h4 id="invalidate()">invalidate()</h4><p>请求重绘View树，即draw()过程，假如视图发生大小没有变化就不会调用layout()过程，并且只绘制那些<strong>需要重绘的</strong>视图，即谁（View的话，只绘制该View ；ViewGroup，则绘制整个ViewGroup）请求invalidate()方法，就绘制该视图。<br>一般引起invalidate()操作的函数如下：</p>
<ol>
<li>直接调用invalidate()方法，请求重新draw()，但只会绘制调用者本身</li>
<li>setSelection()方法，请求重新draw()，但只会绘制调用者本身</li>
<li>setVisibility()方法，当View可视状态在INVISIBLE转换VISIBLE时，会间接调用invalidate()方法，继而绘制该View</li>
<li>setEnabled()方法，请求重新draw()，但不会重新绘制任何视图包括该调用者本身</li>
</ol>
<h4 id="requestLayout()">requestLayout()</h4><p>会导致调用measure()过程和layout()过程，只是对View树重新布局layout过程，包括measure()和layout()过程，但不会调用draw()过程，不会重新绘制任何视图包括该调用者本身。<br>一般引起invalidate()操作的函数如下：</p>
<ol>
<li>setVisibility()方法，当View的可视状态在INVISIBLE/ VISIBLE转换为GONE状态时，会间接调用requestLayout() 和invalidate方法。同时，由于整个个View树大小发生了变化，会请求measure()过程以及draw()过程，同样地，只绘制需要“重新绘制”的视图</li>
</ol>
<h4 id="requestFocus()">requestFocus()</h4><p>请求View树的draw()过程，但只绘制“需要重绘”的视图。</p>
<h2 id="自定义View可能用到的方法">自定义View可能用到的方法</h2><p>官方文档里面列出了自定义一个View可能要继承到的方法，如下：</p>
<table>
<thead>
<tr>
<th style="text-align:center">Category</th>
<th style="text-align:center">Methods</th>
<th style="text-align:center">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">Creation</td>
<td style="text-align:center">Constructors</td>
<td style="text-align:center">There is a form of the constructor that are called when the view is created from code and a form that is called when the view is inflated from a layout file. The second form should parse and apply any attributes defined in the layout file.</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">onFinishInflate()</td>
<td style="text-align:center">Called after a view and all of its children has been inflated from XML.</td>
</tr>
<tr>
<td style="text-align:center">Layout</td>
<td style="text-align:center">onMeasure(int, int)</td>
<td style="text-align:center">Called to determine the size requirements for this view and all of its children.</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">onLayout(boolean, int, int, int, int)</td>
<td style="text-align:center">Called when this view should assign a size and position to all of its children.</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">onSizeChanged(int, int, int, int)</td>
<td style="text-align:center">Called when the size of this view has changed.</td>
</tr>
<tr>
<td style="text-align:center">Drawing</td>
<td style="text-align:center">onDraw(android.graphics.Canvas)</td>
<td style="text-align:center">Called when the view should render its content.</td>
</tr>
<tr>
<td style="text-align:center">Event processing</td>
<td style="text-align:center">onKeyDown(int, KeyEvent)</td>
<td style="text-align:center">Called when a new hardware key event occurs.</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">onKeyUp(int, KeyEvent)</td>
<td style="text-align:center">Called when a hardware key up event occurs.</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">onTrackballEvent(MotionEvent)</td>
<td style="text-align:center">Called when a trackball motion event occurs.</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">onTouchEvent(MotionEvent)</td>
<td style="text-align:center">Called when a touch screen motion event occurs.</td>
</tr>
<tr>
<td style="text-align:center">Focus</td>
<td style="text-align:center">onFocusChanged(boolean, int, android.graphics.Rect)</td>
<td style="text-align:center">Called when the view gains or loses focus.</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">onWindowFocusChanged(boolean)</td>
<td style="text-align:center">Called when the window containing the view gains or loses focus.</td>
</tr>
<tr>
<td style="text-align:center">Attaching</td>
<td style="text-align:center">onAttachedToWindow()</td>
<td style="text-align:center">Called when the view is attached to a window.</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">onDetachedFromWindow()</td>
<td style="text-align:center">Called when the view is detached from its window.</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">onWindowVisibilityChanged(int)</td>
<td style="text-align:center">Called when the visibility of the window containing the view has changed.</td>
</tr>
</tbody>
</table>

    
	</div>
	<footer class="entry-footer">
		<div class="entry-meta-footer">
			<span class="category">
				
			</span>
			<span class="tags">
				
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/android-view/">android view</a></li></ul>

			</span>
		</div>
	</footer>
	
    
<nav id="article-nav">
  
    <a href="/2015/11/10/window/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          Android中的Window浅析
        
      </div>
    </a>
  
  
    <a href="/2015/10/09/bezierBase/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">
        
          贝塞尔曲线原理介绍及基础使用
        
      </div>
    </a>
  
</nav>

  
</article>




    </div>
    <div class="mb-search">
  <form action="//google.com/search" method="get" accept-charset="utf-8">
    <input type="search" name="q" results="0" placeholder="Search">
    <input type="hidden" name="q" value="site:yoursite.com">
  </form>
</div>
<footer id="footer">
	<h1 class="footer-blog-title">
		<a href="/">DoubleChen，就这样</a>
	</h1>
	<span class="copyright">
		&copy; 2015 Double Chen<br>
		Modify from <a href="http://sanographix.github.io/tumblr/apollo/" target="_blank">Apollo</a> theme, designed by <a href="http://www.sanographix.net/" target="_blank">SANOGRAPHIX.NET</a><br>
		Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
	</span>
</footer>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js" type="text/javascript"></script>
  </div>
</body>
</html>