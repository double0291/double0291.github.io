<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>事件分发框架——EventBus浅析 | DoubleChen，就这样</title>
  <meta name="viewport" content="width=device-width">
  <meta name="description" content="简介及基本概念EventBus是Android下一个开源的注册分发（publish/subscrib）事件总线，主要功能是简化了Android各组件以及后台线程之间的相互通信。常见的比如网络请求返回通知UI，两个Fragment之间通信等，都可以通过EventBus实现。EventBus主要包括三个元素：

Event：事件
Subscriber：事件订阅者，接收特定的事件
Publisher：事">
<meta property="og:type" content="article">
<meta property="og:title" content="事件分发框架——EventBus浅析">
<meta property="og:url" content="http://yoursite.com/2015/11/18/eventbus/index.html">
<meta property="og:site_name" content="DoubleChen，就这样">
<meta property="og:description" content="简介及基本概念EventBus是Android下一个开源的注册分发（publish/subscrib）事件总线，主要功能是简化了Android各组件以及后台线程之间的相互通信。常见的比如网络请求返回通知UI，两个Fragment之间通信等，都可以通过EventBus实现。EventBus主要包括三个元素：

Event：事件
Subscriber：事件订阅者，接收特定的事件
Publisher：事">
<meta property="og:image" content="http://yoursite.com/EventBus/class_relation.png">
<meta property="og:updated_time" content="2015-11-18T11:25:28.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="事件分发框架——EventBus浅析">
<meta name="twitter:description" content="简介及基本概念EventBus是Android下一个开源的注册分发（publish/subscrib）事件总线，主要功能是简化了Android各组件以及后台线程之间的相互通信。常见的比如网络请求返回通知UI，两个Fragment之间通信等，都可以通过EventBus实现。EventBus主要包括三个元素：

Event：事件
Subscriber：事件订阅者，接收特定的事件
Publisher：事">
  
    <link rel="alternative" href="/atom.xml" title="DoubleChen，就这样" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  <link rel="stylesheet" href="/css/style.css" type="text/css">
  <!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->
  
</head>
<body>
  <div id="container">
    <div class="mobile-nav-panel">
	<i class="icon-reorder icon-large"></i>
</div>
<header id="header">
	<h1 class="blog-title">
		<a href="/">DoubleChen，就这样</a>
	</h1>
	<nav class="nav">
		<ul>
			<li><a href="/">Home</a></li><li><a href="/archives">Archives</a></li>
			<li><a id="nav-search-btn" class="nav-icon" title="Search"></a></li>
			<li><a href="/atom.xml" id="nav-rss-link" class="nav-icon" title="RSS Feed"></a></li>
		</ul>
	</nav>
	<div id="search-form-wrap">
		<form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" results="0" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
	</div>
</header>
    <div id="main">
      <article id="post-eventbus" class="post">
	<footer class="entry-meta-header">
		<span class="meta-elements date">
			<a href="/2015/11/18/eventbus/" class="article-date">
  <time datetime="2015-11-17T16:00:00.000Z" itemprop="datePublished">2015-11-18</time>
</a>
		</span>
		<span class="meta-elements author">Double Chen</span>
		<div class="commentscount">
			
		</div>
	</footer>
	
	<header class="entry-header">
		
  
    <h1 class="article-title entry-title" itemprop="name">
      事件分发框架——EventBus浅析
    </h1>
  

	</header>
	<div class="entry-content">
		
    	<h2 id="简介及基本概念">简介及基本概念</h2><p>EventBus是Android下一个开源的注册分发（publish/subscrib）事件总线，主要功能是简化了Android各组件以及后台线程之间的相互通信。<br>常见的比如网络请求返回通知UI，两个Fragment之间通信等，都可以通过EventBus实现。<br>EventBus主要包括三个元素：</p>
<ul>
<li>Event：事件</li>
<li>Subscriber：事件订阅者，接收特定的事件</li>
<li>Publisher：事件发布者，用于通知Subscriber有事件发生<a id="more"></a>
</li>
</ul>
<h4 id="Event">Event</h4><p>又可以称为消息，其实就是一个Object，意味着可以是任何对象，随意定义，可以是网络请求返回的字符串，也可以是一个开关状态等。</p>
<h4 id="Subscriber">Subscriber</h4><p>要进行事件订阅，就需要在类中实现以onEvent开头的函数，函数名包括<em>onEvent</em>，<em>onEventMainThread</em>，<em>onEventBackgroundThread</em>，<em>onEventAsync</em>这四个，具体使用跟<em>ThreadMode</em>有关，这个下文有阐述。</p>
<h4 id="Publisher">Publisher</h4><p>可以在任意线程任意位置发送任意事件，直接调用EventBus的<em>post(Object)</em>即可。根据post函数的参数类型，会自动调用订阅相关Event的函数。</p>
<h4 id="ThreadMode">ThreadMode</h4><p>EventBus共包括4个ThreadMode，分别是：</p>
<ul>
<li>MainThread，对应方法<em>onEventMainThread()</em>，代表方法会在UI线程执行</li>
<li>PostThread，对应方法<em>onEventPostThread()</em>，代表方法会在当前发布事件的线程执行</li>
<li>BackgroundThread，对应方法<em>onEventBackgroundThread()</em>，代表方法如果是在非UI线程发布的事件，则直接执行，和发布在同一个线程中。如果在UI线程发布的事件，则加入后台任务队列，使用线程池一个接一个调用</li>
<li>Async，对应方法<em>onEventAsync()</em>，代表方法加入后台任务队列，使用线程池调用，<strong>注意没有BackgroundThread中的一个接一个</strong></li>
</ul>
<h2 id="基本使用">基本使用</h2><p>根据官网，基本使用包括以下三步：</p>
<ol>
<li><p>定义事件</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MessageEvent</span> </span>&#123; <span class="comment">/* Additional fields if needed */</span> &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>建立订阅者</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">eventBus.register(<span class="keyword">this</span>);</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onEvent</span><span class="params">(AnyEventType event)</span> </span>&#123;<span class="comment">/* Do something */</span>&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>事件分发</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">eventBus.post(event);</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="源码解析">源码解析</h2><h4 id="核心变量">核心变量</h4><p>先来看看几个核心的Map：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// EventType -&gt; List&lt;? extends EventType&gt;，事件到它的父事件列表的映射。即缓存一个类的所有父类</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Map&lt;Class&lt;?&gt;, List&lt;Class&lt;?&gt;&gt;&gt; eventTypesCache = <span class="keyword">new</span> HashMap&lt;Class&lt;?&gt;, List&lt;Class&lt;?&gt;&gt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">// EventType -&gt; List&lt;Subscription&gt;，事件到订阅对象之间的映射</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;Class&lt;?&gt;, CopyOnWriteArrayList&lt;Subscription&gt;&gt; subscriptionsByEventType;</span><br><span class="line"><span class="comment">// Subscriber -&gt; List&lt;EventType&gt;，订阅源到它订阅的的所有事件类型的映射</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;Object, List&lt;Class&lt;?&gt;&gt;&gt; typesBySubscriber;</span><br><span class="line"><span class="comment">// stickEvent事件，一般不太用</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;Class&lt;?&gt;, Object&gt; stickyEvents;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span><br><span class="line">* CopyOnWriteArrayList:</span><br><span class="line">* 在CopyOnWriteArrayList里处理写操作（包括add、remove、set等）是先将原始的数据通过JDK1.6的Arrays.copyof()来生成一份新的数组，</span><br><span class="line">* 然后在新的数据对象上进行写，写完后再将原来的引用指向到当前这个数据对象（这里应用了常识1），</span><br><span class="line">* 这样保证了每次写都是在新的对象上（因为要保证写的一致性，这里要对各种写操作要加一把锁，JDK1.6在这里用了重入锁），</span><br><span class="line">* 然后读的时候就是在引用的当前对象上进行读（包括get，iterator等），</span><br><span class="line">* CopyOnWriteArrayList适合使用在读操作远远大于写操作的场景里，比如缓存</span><br><span class="line">*/</span></span><br></pre></td></tr></table></figure></p>
<h4 id="register">register</h4><p>注册分发的具体流程首先从注册开始看，register对外暴露了4个方法，分别是：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">register</span><span class="params">(Object subscriber)</span> </span>&#123;</span><br><span class="line">	register(subscriber, <span class="keyword">false</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">register</span><span class="params">(Object subscriber, <span class="keyword">int</span> priority)</span> </span>&#123;</span><br><span class="line">	register(subscriber, <span class="keyword">false</span>, priority);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerSticky</span><span class="params">(Object subscriber)</span> </span>&#123;</span><br><span class="line">	register(subscriber, <span class="keyword">true</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerSticky</span><span class="params">(Object subscriber, <span class="keyword">int</span> priority)</span> </span>&#123;</span><br><span class="line">	register(subscriber, <span class="keyword">true</span>, priority);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>可以看到，针对不同的参数，提供了不同的register方法，这3个参数分别是：</p>
<ol>
<li>subscriber，订阅者，常见是Android组件。</li>
<li>sticky，粘性，<strong>如果sticky为true，那么当事件发布之后，再有订阅者开始订阅该类型事件的话，就依然能收到该类型事件最近的一个sticky事件</strong>，一般用不上，默认false。有的时候，比如位置信息，时间信息，新注册的时间可能用得上。</li>
<li>priority，优先级，<strong>优先级高的订阅者可以取消事件继续向优先级低的订阅者分发</strong>，默认所有订阅者优先级都为0。</li>
</ol>
<p>真正的register内部实现是：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">register</span><span class="params">(Object subscriber, <span class="keyword">boolean</span> sticky, <span class="keyword">int</span> priority)</span> </span>&#123;</span><br><span class="line">	List&lt;SubscriberMethod&gt; subscriberMethods = subscriberMethodFinder.findSubscriberMethods(subscriber.getClass());</span><br><span class="line">	<span class="keyword">for</span> (SubscriberMethod subscriberMethod : subscriberMethods) &#123;</span><br><span class="line">		subscribe(subscriber, subscriberMethod, sticky, priority);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>可以看到，首先通过一个<em>findSubscriberMethods</em>方法去找到这个订阅者的所有订阅方法，返回一个List<subscribermethod>。<br>来看看<em>findSubscriberMethods</em>：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">List&lt;SubscriberMethod&gt; <span class="title">findSubscriberMethods</span><span class="params">(Class&lt;?&gt; subscriberClass)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 通过订阅者类名定义一个key</span></span><br><span class="line">	String key = subscriberClass.getName();</span><br><span class="line">	List&lt;SubscriberMethod&gt; subscriberMethods;</span><br><span class="line">	<span class="keyword">synchronized</span> (methodCache) &#123;</span><br><span class="line">		<span class="comment">// 判断是否有缓存</span></span><br><span class="line">		subscriberMethods = methodCache.get(key);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (subscriberMethods != <span class="keyword">null</span>) &#123;</span><br><span class="line">		<span class="comment">// 有缓存直接返回缓存，第一次进的话肯定为null</span></span><br><span class="line">		<span class="keyword">return</span> subscriberMethods;</span><br><span class="line">	&#125;</span><br><span class="line">	subscriberMethods = <span class="keyword">new</span> ArrayList&lt;SubscriberMethod&gt;();</span><br><span class="line">	Class&lt;?&gt; clazz = subscriberClass;</span><br><span class="line">	HashMap&lt;String, Class&gt; eventTypesFound = <span class="keyword">new</span> HashMap&lt;String, Class&gt;();</span><br><span class="line">	StringBuilder methodKeyBuilder = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">	<span class="keyword">while</span> (clazz != <span class="keyword">null</span>) &#123;</span><br><span class="line">		String name = clazz.getName();</span><br><span class="line">		<span class="comment">// 过滤掉系统类</span></span><br><span class="line">		<span class="keyword">if</span> (name.startsWith(<span class="string">"java."</span>) || name.startsWith(<span class="string">"javax."</span>) || name.startsWith(<span class="string">"android."</span>)) &#123;</span><br><span class="line">			<span class="comment">// Skip system classes, this just degrades performance</span></span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Starting with EventBus 2.2 we enforced methods to be public (might change with annotations again)</span></span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="comment">// 通过反射获取订阅者的所有方法，注意这边用getDeclaredMethods()而不是getMethods()，能少获取很多无用的方法</span></span><br><span class="line">			<span class="comment">// This is faster than getMethods, especially when subscribers a fat classes like Activities</span></span><br><span class="line">			Method[] methods = clazz.getDeclaredMethods();</span><br><span class="line">			<span class="comment">// 过滤出onEvent开头的方法</span></span><br><span class="line">			filterSubscriberMethods(subscriberMethods, eventTypesFound, methodKeyBuilder, methods);</span><br><span class="line">		&#125; <span class="keyword">catch</span> (Throwable th) &#123;</span><br><span class="line">			th.printStackTrace();</span><br><span class="line">			<span class="comment">// Workaround for java.lang.NoClassDefFoundError, see https://github.com/greenrobot/EventBus/issues/149</span></span><br><span class="line">			Method[] methods = subscriberClass.getMethods();</span><br><span class="line">			subscriberMethods.clear();</span><br><span class="line">			eventTypesFound.clear();</span><br><span class="line">			filterSubscriberMethods(subscriberMethods, eventTypesFound, methodKeyBuilder, methods);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 还会遍历父类的订阅函数</span></span><br><span class="line">		clazz = clazz.getSuperclass();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 最后加入缓存，第二次使用直接从缓存取</span></span><br><span class="line">	<span class="keyword">if</span> (subscriberMethods.isEmpty()) &#123;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> EventBusException(<span class="string">"Subscriber "</span> + subscriberClass + <span class="string">" has no public methods called "</span></span><br><span class="line">				+ ON_EVENT_METHOD_NAME);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">synchronized</span> (methodCache) &#123;</span><br><span class="line">			methodCache.put(key, subscriberMethods);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> subscriberMethods;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">filterSubscriberMethods</span><span class="params">(List&lt;SubscriberMethod&gt; subscriberMethods,</span><br><span class="line">                                         HashMap&lt;String, Class&gt; eventTypesFound, StringBuilder methodKeyBuilder,</span><br><span class="line">                                         Method[] methods)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (Method method : methods) &#123;</span><br><span class="line">		String methodName = method.getName();</span><br><span class="line">		<span class="comment">// 只获取onEvent开头的方法</span></span><br><span class="line">		<span class="keyword">if</span> (methodName.startsWith(ON_EVENT_METHOD_NAME)) &#123;</span><br><span class="line">			<span class="keyword">int</span> modifiers = method.getModifiers();</span><br><span class="line">			Class&lt;?&gt; methodClass = method.getDeclaringClass();</span><br><span class="line">			<span class="comment">// 判断订阅函数是否是public的,并且是否有修饰符</span></span><br><span class="line">			<span class="comment">// 看来订阅函数只能是public的，并且不能被final，static等修饰</span></span><br><span class="line">			<span class="keyword">if</span> ((modifiers &amp; Modifier.PUBLIC) != <span class="number">0</span> &amp;&amp; (modifiers &amp; MODIFIERS_IGNORE) == <span class="number">0</span>) &#123;</span><br><span class="line">				<span class="comment">// 获取订阅函数的参数 </span></span><br><span class="line">				Class&lt;?&gt;[] parameterTypes = method.getParameterTypes();</span><br><span class="line">				<span class="comment">// 参数只能有1个</span></span><br><span class="line">				<span class="keyword">if</span> (parameterTypes.length == <span class="number">1</span>) &#123;</span><br><span class="line">					<span class="comment">// 根据onEvent后面的部分获取ThreadMode</span></span><br><span class="line">					ThreadMode threadMode = getThreadMode(methodClass, method, methodName);</span><br><span class="line">					<span class="keyword">if</span> (threadMode == <span class="keyword">null</span>) &#123;</span><br><span class="line">						<span class="keyword">continue</span>;</span><br><span class="line">					&#125;</span><br><span class="line">					<span class="comment">// 获取参数类型，其实就是接收事件的类型</span></span><br><span class="line">					Class&lt;?&gt; eventType = parameterTypes[<span class="number">0</span>];</span><br><span class="line">					methodKeyBuilder.setLength(<span class="number">0</span>);</span><br><span class="line">					methodKeyBuilder.append(methodName);</span><br><span class="line">					methodKeyBuilder.append(<span class="string">'&gt;'</span>).append(eventType.getName());</span><br><span class="line">					String methodKey = methodKeyBuilder.toString();</span><br><span class="line">					Class methodClassOld = eventTypesFound.put(methodKey, methodClass);</span><br><span class="line">					<span class="keyword">if</span> (methodClassOld == <span class="keyword">null</span> || methodClassOld.isAssignableFrom(methodClass)) &#123;</span><br><span class="line">						<span class="comment">// Only add if not already found in a sub class</span></span><br><span class="line">						<span class="comment">// 封装一个订阅方法对象，这个对象包含Method对象，threadMode对象，eventType对象  </span></span><br><span class="line">						subscriberMethods.add(<span class="keyword">new</span> SubscriberMethod(method, threadMode, eventType));</span><br><span class="line">					&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">						<span class="comment">// Revert the put, old class is further down the class hierarchy</span></span><br><span class="line">						eventTypesFound.put(methodKey, methodClassOld);</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125; <span class="keyword">else</span> <span class="keyword">if</span> (!skipMethodVerificationForClasses.containsKey(methodClass)) &#123;</span><br><span class="line">				Log.d(EventBus.TAG, <span class="string">"Skipping method (not public, static or abstract): "</span> + methodClass + <span class="string">"."</span></span><br><span class="line">						+ methodName);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></subscribermethod></p>
<p>关于<em>findSubscriberMethods</em>，我们要注意两点：</p>
<ol>
<li>所有事件处理方法<strong>必需是<code>public void</code>类型</strong>的，并且只有一个参数表示<em>EventType</em></li>
<li><em>findSubscriberMethods</em>不只查找<em>Subscriber</em>内的事件处理方法，<strong>同时还会查到它的继承体系中的所有基类中的事件处理方法</strong></li>
</ol>
<p>重回<em>register</em>方法，获取到了Subscriber的订阅函数之后，就要对每个找到的订阅函数调用<em>subscribe</em>进行注册了。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Must be called in synchronized block</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">subscribe</span><span class="params">(Object subscriber, SubscriberMethod subscriberMethod, <span class="keyword">boolean</span> sticky, <span class="keyword">int</span> priority)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 从订阅方法中获得订阅的事件类型</span></span><br><span class="line">	Class&lt;?&gt; eventType = subscriberMethod.eventType;</span><br><span class="line">	<span class="comment">// 通过订阅事件类型，找到所有的订阅（Subscription），订阅中包含了订阅者和订阅方法</span></span><br><span class="line">	CopyOnWriteArrayList&lt;Subscription&gt; subscriptions = subscriptionsByEventType.get(eventType);</span><br><span class="line">	<span class="comment">// 创建一个新的订阅</span></span><br><span class="line">	Subscription newSubscription = <span class="keyword">new</span> Subscription(subscriber, subscriberMethod, priority);</span><br><span class="line">	<span class="keyword">if</span> (subscriptions == <span class="keyword">null</span>) &#123;</span><br><span class="line">		<span class="comment">// 如果该事件没有订阅列表，就创建一个并加入该订阅</span></span><br><span class="line">		subscriptions = <span class="keyword">new</span> CopyOnWriteArrayList&lt;Subscription&gt;();</span><br><span class="line">		subscriptionsByEventType.put(eventType, subscriptions);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">// 如果已有订阅列表，检查是否已经加入过</span></span><br><span class="line">		<span class="keyword">if</span> (subscriptions.contains(newSubscription)) &#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> EventBusException(<span class="string">"Subscriber "</span> + subscriber.getClass() + <span class="string">" already registered to event "</span></span><br><span class="line">					+ eventType);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Starting with EventBus 2.2 we enforced methods to be public (might change with annotations again)</span></span><br><span class="line">	<span class="comment">// subscriberMethod.method.setAccessible(true);</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 根据优先级插入订阅</span></span><br><span class="line">	<span class="keyword">int</span> size = subscriptions.size();</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= size; i++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (i == size || newSubscription.priority &gt; subscriptions.get(i).priority) &#123;</span><br><span class="line">			subscriptions.add(i, newSubscription);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 将这个订阅事件加入到订阅者的订阅事件列表中</span></span><br><span class="line">	List&lt;Class&lt;?&gt;&gt; subscribedEvents = typesBySubscriber.get(subscriber);</span><br><span class="line">	<span class="keyword">if</span> (subscribedEvents == <span class="keyword">null</span>) &#123;</span><br><span class="line">		subscribedEvents = <span class="keyword">new</span> ArrayList&lt;Class&lt;?&gt;&gt;();</span><br><span class="line">		typesBySubscriber.put(subscriber, subscribedEvents);</span><br><span class="line">	&#125;</span><br><span class="line">	subscribedEvents.add(eventType);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 对粘性事件的处理</span></span><br><span class="line">	<span class="keyword">if</span> (sticky) &#123;</span><br><span class="line">		<span class="keyword">if</span> (eventInheritance) &#123;</span><br><span class="line">			<span class="comment">// Existing sticky events of all subclasses of eventType have to be considered.</span></span><br><span class="line">			<span class="comment">// Note: Iterating over all events may be inefficient with lots of sticky events,</span></span><br><span class="line">			<span class="comment">// thus data structure should be changed to allow a more efficient lookup</span></span><br><span class="line">			<span class="comment">// (e.g. an additional map storing sub classes of super classes: Class -&gt; List&lt;Class&gt;).</span></span><br><span class="line">			Set&lt;Map.Entry&lt;Class&lt;?&gt;, Object&gt;&gt; entries = stickyEvents.entrySet();</span><br><span class="line">			<span class="keyword">for</span> (Map.Entry&lt;Class&lt;?&gt;, Object&gt; entry : entries) &#123;</span><br><span class="line">				Class&lt;?&gt; candidateEventType = entry.getKey();</span><br><span class="line">				<span class="keyword">if</span> (eventType.isAssignableFrom(candidateEventType)) &#123;</span><br><span class="line">					Object stickyEvent = entry.getValue();</span><br><span class="line">					checkPostStickyEventToSubscription(newSubscription, stickyEvent);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			Object stickyEvent = stickyEvents.get(eventType);</span><br><span class="line">			checkPostStickyEventToSubscription(newSubscription, stickyEvent);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里<em>subscribe</em>方法主要干了3件事情：</p>
<ol>
<li>根据<em>SubscriberMethod</em>中的<em>EventType</em>类型将<em>Subscribtion</em>对象存放在<em>subscriptionsByEventType</em>中。建立<em>EventType</em>到<em>Subscription</em>的映射，每个事件可以有多个订阅者。</li>
<li>根据<em>Subscriber</em>将<em>EventType</em>存放在<em>typesBySubscriber</em>中，建立<em>Subscriber</em>到<em>EventType</em>的映射，每个Subscriber可以订阅多个事件。</li>
<li>如果是<em>Sticky</em>类型的订阅者，直接向它发送上个保存的事件（如果有的话）。</li>
</ol>
<p>通过<em>Subscriber</em>到<em>EventType</em>的映射，我们就可以很方便地使一个Subscriber取消接收事件，而通过<em>EventType</em>到<em>Sucscribtion</em>的映射，可以方便地将相应的事件发送到它的每一个订阅者。    </p>
<blockquote>
<p>一句话总结，<strong>register(this)就是去当前类，遍历所有的方法，找到onEvent开头的然后进行存储</strong>。</p>
</blockquote>
<h4 id="post">post</h4><p>看完了register，现在来看post过程。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** Posts the given event to the event bus. */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">post</span><span class="params">(Object event)</span> </span>&#123;</span><br><span class="line">	PostingThreadState postingState = currentPostingThreadState.get();</span><br><span class="line">	List&lt;Object&gt; eventQueue = postingState.eventQueue;</span><br><span class="line">	<span class="comment">// 将事件放入队列</span></span><br><span class="line">	eventQueue.add(event);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!postingState.isPosting) &#123;</span><br><span class="line">		postingState.isMainThread = Looper.getMainLooper() == Looper.myLooper();</span><br><span class="line">		postingState.isPosting = <span class="keyword">true</span>;</span><br><span class="line">		<span class="keyword">if</span> (postingState.canceled) &#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> EventBusException(<span class="string">"Internal error. Abort state was not reset"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="keyword">while</span> (!eventQueue.isEmpty()) &#123;</span><br><span class="line">				<span class="comment">// 事件分发</span></span><br><span class="line">				postSingleEvent(eventQueue.remove(<span class="number">0</span>), postingState);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">			postingState.isPosting = <span class="keyword">false</span>;</span><br><span class="line">			postingState.isMainThread = <span class="keyword">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>可以看到post内使用了<em>PostingThreadState</em>的对象，并且是<code>ThreadLocal</code>，来看<em>PostingThreadState</em>的定义：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** For ThreadLocal, much faster to set (and get multiple values). */</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">PostingThreadState</span> </span>&#123;</span><br><span class="line">	<span class="keyword">final</span> List&lt;Object&gt; eventQueue = <span class="keyword">new</span> ArrayList&lt;Object&gt;();</span><br><span class="line">	<span class="keyword">boolean</span> isPosting;</span><br><span class="line">	<span class="keyword">boolean</span> isMainThread;</span><br><span class="line">	Subscription subscription;</span><br><span class="line">	Object event;</span><br><span class="line">	<span class="keyword">boolean</span> canceled;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>主要是有个成员<em>eventQueue</em>，由于是ThreadLocal，所以结果就是，每个线程有一个<em>PostingThreadState</em>对象，这个对象内部有一个事件的队列，并且有一个成员<em>isPosting</em>表示现在是否正在派发事件，当发送事件开始时，会依次取出队列中的事件发送出去，如果正在派发事件，那么post直接把事件加入队列后返回，还有个成员<em>isMainThread</em>，这个成员在实际派发事件时会用到，在<em>postSingleEvent</em>中会用到。<br>接着在<em>post</em>函数里面往下看，可以看到，事件分发主要是在<em>postSingleEvent</em>函数里面进行的：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">postSingleEvent</span><span class="params">(Object event, PostingThreadState postingState)</span> <span class="keyword">throws</span> Error </span>&#123;</span><br><span class="line">	Class&lt;?&gt; eventClass = event.getClass();</span><br><span class="line">	<span class="keyword">boolean</span> subscriptionFound = <span class="keyword">false</span>;</span><br><span class="line">	<span class="keyword">if</span> (eventInheritance) &#123;</span><br><span class="line">		<span class="comment">// 找到eventClass对应的事件，包含父类对应的事件和接口对应的事件</span></span><br><span class="line">		List&lt;Class&lt;?&gt;&gt; eventTypes = lookupAllEventTypes(eventClass);</span><br><span class="line">		<span class="keyword">int</span> countTypes = eventTypes.size();</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> h = <span class="number">0</span>; h &lt; countTypes; h++) &#123;</span><br><span class="line">			Class&lt;?&gt; clazz = eventTypes.get(h);</span><br><span class="line">			subscriptionFound |= postSingleEventForEventType(event, postingState, clazz);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		subscriptionFound = postSingleEventForEventType(event, postingState, eventClass);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 如果没有订阅发现，那么会Post一个NoSubscriberEvent事件</span></span><br><span class="line">	<span class="keyword">if</span> (!subscriptionFound) &#123;</span><br><span class="line">		<span class="keyword">if</span> (logNoSubscriberMessages) &#123;</span><br><span class="line">			Log.d(TAG, <span class="string">"No subscribers registered for event "</span> + eventClass);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (sendNoSubscriberEvent &amp;&amp; eventClass != NoSubscriberEvent.class &amp;&amp;</span><br><span class="line">				eventClass != SubscriberExceptionEvent.class) &#123;</span><br><span class="line">			post(<span class="keyword">new</span> NoSubscriberEvent(<span class="keyword">this</span>, event));</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><em>eventInheritance</em>是什么？先不管，往里面看。</p>
<ol>
<li>第一步是一个<em>lookupAllEventTypes</em>函数，这个函数的作用是<strong>把这个类的类对象、实现的接口及父类的类对象存到一个List中返回</strong>。    </li>
<li>第二步就是遍历第一步获取到的List了，对List中的每一个对象执行第三步。    </li>
<li>第三步就是找到这个事件类型的所有订阅者向其发送事件。</li>
</ol>
<p>这样我们就懂得了<em>eventInheritance</em>的含义了。如果为true，<strong>当我们Post一个事件时，这个事件的父事件（事件类的父类的事件）也会被Post，所以如果有个事件订阅者接收Object类型的事件，那么它就可以接收到所有的事件</strong>。<br><em>eventInheritance</em>默认为true，可以在EventBus的构造器EventBusBuilder里面设置。<br>上面说的第三步就是真正的事件分发了：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">postSingleEventForEventType</span><span class="params">(Object event, PostingThreadState postingState, Class&lt;?&gt; eventClass)</span> </span>&#123;</span><br><span class="line">	CopyOnWriteArrayList&lt;Subscription&gt; subscriptions;</span><br><span class="line">	<span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">		<span class="comment">// 找到订阅事件对应的订阅，这个是通过register加入的</span></span><br><span class="line">		subscriptions = subscriptionsByEventType.get(eventClass);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (subscriptions != <span class="keyword">null</span> &amp;&amp; !subscriptions.isEmpty()) &#123;</span><br><span class="line">		<span class="keyword">for</span> (Subscription subscription : subscriptions) &#123;</span><br><span class="line">			postingState.event = event;</span><br><span class="line">			postingState.subscription = subscription;</span><br><span class="line">			<span class="keyword">boolean</span> aborted = <span class="keyword">false</span>;</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				<span class="comment">// 调用每个订阅者的订阅方法</span></span><br><span class="line">				postToSubscription(subscription, event, postingState.isMainThread);</span><br><span class="line">				aborted = postingState.canceled;</span><br><span class="line">			&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">				postingState.event = <span class="keyword">null</span>;</span><br><span class="line">				postingState.subscription = <span class="keyword">null</span>;</span><br><span class="line">				postingState.canceled = <span class="keyword">false</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (aborted) &#123;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>看看核心的<em>postToSubscription</em>方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* subscription : 订阅者</span><br><span class="line">* event : 分发的事件</span><br><span class="line">* isMainThread : 是否在主线程</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">postToSubscription</span><span class="params">(Subscription subscription, Object event, <span class="keyword">boolean</span> isMainThread)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">switch</span> (subscription.subscriberMethod.threadMode) &#123;</span><br><span class="line">		<span class="keyword">case</span> PostThread:</span><br><span class="line">			<span class="comment">// 直接在本线程中调用订阅函数</span></span><br><span class="line">			invokeSubscriber(subscription, event);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> MainThread:</span><br><span class="line">			<span class="keyword">if</span> (isMainThread) &#123;</span><br><span class="line">				<span class="comment">// 当前是主线程，那就直接调用订阅函数</span></span><br><span class="line">				invokeSubscriber(subscription, event);</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="comment">// 当前是子线程，通过handler实现在主线程中执行</span></span><br><span class="line">				mainThreadPoster.enqueue(subscription, event);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> BackgroundThread:</span><br><span class="line">			<span class="keyword">if</span> (isMainThread) &#123;</span><br><span class="line">				<span class="comment">// 当前是主线程，创建一个runnable丢到线程池里面</span></span><br><span class="line">				backgroundPoster.enqueue(subscription, event);</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="comment">// 当前是子线程，直接调用</span></span><br><span class="line">				invokeSubscriber(subscription, event);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> Async:</span><br><span class="line">			<span class="comment">// 不论什么线程，直接丢入线程池</span></span><br><span class="line">			asyncPoster.enqueue(subscription, event);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">default</span>:</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Unknown thread mode: "</span> + subscription.subscriberMethod.threadMode);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><em>invokeSubscriber</em>函数利用了反射直接执行一个订阅者的订阅函数。</p>
<h6 id="BackgroundPoster">BackgroundPoster</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">BackgroundPoster</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> PendingPostQueue queue;</span><br><span class="line">	...</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(Subscription subscription, Object event)</span> </span>&#123;</span><br><span class="line">        PendingPost pendingPost = PendingPost.obtainPendingPost(subscription, event);</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            queue.enqueue(pendingPost);</span><br><span class="line">            <span class="keyword">if</span> (!executorRunning) &#123;</span><br><span class="line">                executorRunning = <span class="keyword">true</span>;</span><br><span class="line">                eventBus.getExecutorService().execute(<span class="keyword">this</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>PendingPostQueue是一个PendingPost对象的队列，当<em>enqueue()</em>时就把待发送的事件被封装成了PendingPost对象放到队列中。<br>BackgroundPoster其实就是一个Runnable对象，当<em>enqueue</em>时，如果这个Runnable对象当前没被执行，就将BackgroundPoster加入EventBus中的一个线程池中，当BackgroundPoster被执行时，会依次取出队列中的事件进行派发。当长时间无事件时BackgroundPoster所属的线程被会销毁，下次再Post事件时再创建新的线程。</p>
<h6 id="HandlerPoster">HandlerPoster</h6><p><em>mainThreadPoster</em>是一个HandlerPoster对象，继承自Handler，构造函数中接收了一个Looper对象。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">HandlerPoster</span> <span class="keyword">extends</span> <span class="title">Handler</span> </span>&#123;</span><br><span class="line">	...</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(Subscription subscription, Object event)</span> </span>&#123;</span><br><span class="line">        PendingPost pendingPost = PendingPost.obtainPendingPost(subscription, event);</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            queue.enqueue(pendingPost);</span><br><span class="line">            <span class="keyword">if</span> (!handlerActive) &#123;</span><br><span class="line">                handlerActive = <span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">if</span> (!sendMessage(obtainMessage())) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> EventBusException(<span class="string">"Could not send handler message"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>调用<em>enqueue()</em>方法时，会像BackgroundPoster一样把这个事件加入队列中， 只是如果当前没在派发消息就向自身发送Message。<br>在<em>handleMessage</em>中会依次取出队列中的消息交由EventBus直接调用事件处理函数，而<em>handleMessage</em>执行所在的线程就是构造函数中传进来的Looper所属的线程，在EventBus中构造mainThreadPoster时传进来的是MainLooper，所以会在UI线程中执行。</p>
<h6 id="AsyncPoster">AsyncPoster</h6><p>AsyncPoster就把每个事件都加入线程池中处理<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AsyncPoster</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">	...</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(Subscription subscription, Object event)</span> </span>&#123;</span><br><span class="line">        PendingPost pendingPost = PendingPost.obtainPendingPost(subscription, event);</span><br><span class="line">        queue.enqueue(pendingPost);</span><br><span class="line">        eventBus.getExecutorService().execute(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>一句话总结，<strong>post就是把一个Event发出去，EventBus会在它内部存储的方法中，进行扫描，找到参数匹配的，就使用反射进行调用</strong>。</p>
</blockquote>
<h4 id="StickyEvent">StickyEvent</h4><p>EventBus除了提供了<em>post</em>方法，还提供了一个<em>postSticky</em>方法。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Posts the given event to the event bus and holds on to the event (because it is sticky). The most recent sticky</span><br><span class="line"> * event of an event's type is kept in memory for future access. This can be &#123;<span class="doctag">@link</span> #registerSticky(Object)&#125; or</span><br><span class="line"> * &#123;<span class="doctag">@link</span> #getStickyEvent(Class)&#125;.</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postSticky</span><span class="params">(Object event)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">synchronized</span> (stickyEvents) &#123;</span><br><span class="line">		stickyEvents.put(event.getClass(), event);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// Should be posted after it is putted, in case the subscriber wants to remove immediately</span></span><br><span class="line">	post(event);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>和post功能类似，但是会把方法存储到stickyEvents中去。<br>当通过<em>postSticky</em>发送一个事件时，这个类型的事件的最后一次事件会被缓存起来，当有订阅者通过<em>registerSticky</em>注册时，会把之前缓存起来的这个事件直接发送给它。</p>
<h2 id="一些类信息">一些类信息</h2><p>盗图一张：<br><img src="/EventBus/class_relation.png" alt="class_relation"></p>
<h4 id="EventBus">EventBus</h4><p>EventBus类负责所有对外暴露的API，其中的<em>register()</em>、<em>post()</em>、<em>unregister()</em>函数配合上自定义的EventType及事件响应函数即可完成核心功能。<br>EventBus默认可通过静态函数<em>getDefault</em>获取单例，当然有需要也可以通过’EventBusBuilder’或 构造函数新建一个EventBus，每个新建的EventBus发布和订阅事件都是相互隔离的，即一个EventBus对象中的发布者发布事件，另一个EventBus对象中的订阅者不会收到该订阅。</p>
<h4 id="EventBusBuilder">EventBusBuilder</h4><p>跟一般Builder类似，用于在需要设置参数过多时构造EventBus。包含的属性也是EventBus的一些设置参数。<em>build函</em>数用于新建EventBus对象，<em>installDefaultEventBus</em>函数将当前设置应用于Default EventBus。</p>
<h4 id="SubscriberMethodFinder">SubscriberMethodFinder</h4><p>订阅者响应函数信息存储和查找类，上面具体分析过了，主要用于查找订阅者响应函数，如果不在缓存中，则遍历自己的每个函数并递归父类查找，查找成功后保存到缓存中。</p>
<h4 id="SubscriberMethod">SubscriberMethod</h4><p>订阅者事件响应函数信息，包括响应方法、线程Mode、事件类型以及一个用来比较SubscriberMethod是否相等的特征值methodString，共四个变量。</p>
<h4 id="Subscription">Subscription</h4><p>订阅者信息，包括subscriber对象、事件响应方法SubscriberMethod、优先级priority。</p>
<h4 id="HandlerPoster-1">HandlerPoster</h4><p>事件主线程处理，对应’ThreadMode.MainThread’。继承自Handler，<em>enqueue</em>函数将事件放到队列中，并利用handler发送message，<em>handleMessage</em>函数从队列中取事件，invoke事件响应函数处理。</p>
<h4 id="AsyncPoster-1">AsyncPoster</h4><p>事件异步线程处理，对应’ThreadMode.Async’，继承自Runnable。<em>enqueue</em>函数将事件放到队列中，并调用线程池执行当前任务，在<em>run</em>函数从队列中取事件，invoke事件响应函数处理。</p>
<h4 id="BackgroundPoster-1">BackgroundPoster</h4><p>事件Background处理，对应’ThreadMode.BackgroundThread’，继承自Runnable。<em>enqueue</em>函数将事件放到队列中，并调用线程池执行当前任务，在<em>run</em>函数从队列中取事件，invoke事件响应函数处理。与AsyncPoster不同的是，BackgroundPoster中的任务<strong>只在同一个线程中依次执行，而不是并发执行</strong>。</p>
<h4 id="PendingPost">PendingPost</h4><p>订阅者和事件信息实体类，并含有同一队列中指向下一个对象的指针。通过缓存存储不用的对象，减少下次创建的性能消耗。</p>
<h4 id="PendingPostQueue">PendingPostQueue</h4><p>通过head和tail指针维护一个’PendingPost’队列。’HandlerPoster’、’AsyncPoster’、’BackgroundPoster’都包含一个此队列实例，表示各自的订阅者及事件信息队列，在事件到来时进入队列，处理时从队列中取出一个元素进行处理。</p>
<h4 id="SubscriberExceptionEvent">SubscriberExceptionEvent</h4><p>当调用事件处理函数异常时发送的EventBus内部自定义事件，通过post发送，订阅者可自行订阅这类事件进行处理。</p>
<h4 id="NoSubscriberEvent">NoSubscriberEvent</h4><p>当没有事件处理函数对事件处理时发送的EventBus内部自定义事件，通过post发送，订阅者可自行订阅这类事件进行处理。</p>
<h4 id="EventBusException">EventBusException</h4><p>封装于’RuntimeException’之上的Exception，只是覆盖构造函数，相当于一个标记，标记是属于EventBus的Exception。</p>
<h4 id="ThreadMode-1">ThreadMode</h4><p>线程Mode枚举类，表示事件响应函数执行线程信息，包括’ThreadMode.PostThread’、’ThreadMode.MainThread’、’ThreadMode.BackgroundThread’、’ThreadMode.Async’四种。</p>
<h2 id="注意点">注意点</h2><ol>
<li>不支持进程间通信</li>
<li>同一个onEvent函数不能被注册两次，所以不能在一个类中注册同时还在父类中注册</li>
<li>默认情况下，当Post一个事件时，这个事件类的父类的事件也会被Post</li>
<li>Post的事件无Subscriber处理时会Post一个NoSubscriberEvent事件</li>
</ol>
<h2 id="总结">总结</h2><p>EventBus就是在内部存储了一堆onEvent开头的方法，然后post的时候，根据post传入的参数（Event），去找到匹配的方法，反射调用之。<br>更简单一点，EventBus就是一个单例内部维持着一个map对象存储了一堆的方法；post无非就是根据参数去查找方法，进行反射调用。</p>

    
	</div>
	<footer class="entry-footer">
		<div class="entry-meta-footer">
			<span class="category">
				
			</span>
			<span class="tags">
				
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/android-EventBus/">android EventBus</a></li></ul>

			</span>
		</div>
	</footer>
	
    
<nav id="article-nav">
  
  
    <a href="/2015/11/17/hierarchyViewer/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">
        
          Android的UI分析利器——Hierarchy Viewer
        
      </div>
    </a>
  
</nav>

  
</article>




    </div>
    <div class="mb-search">
  <form action="//google.com/search" method="get" accept-charset="utf-8">
    <input type="search" name="q" results="0" placeholder="Search">
    <input type="hidden" name="q" value="site:yoursite.com">
  </form>
</div>
<footer id="footer">
	<h1 class="footer-blog-title">
		<a href="/">DoubleChen，就这样</a>
	</h1>
	<span class="copyright">
		&copy; 2015 Double Chen<br>
		Modify from <a href="http://sanographix.github.io/tumblr/apollo/" target="_blank">Apollo</a> theme, designed by <a href="http://www.sanographix.net/" target="_blank">SANOGRAPHIX.NET</a><br>
		Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
	</span>
</footer>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js" type="text/javascript"></script>
  </div>
</body>
</html>